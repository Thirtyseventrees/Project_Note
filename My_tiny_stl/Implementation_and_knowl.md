- [æ”¶è·](#æ”¶è·)
- [æœªå®Œæˆè·³è¿‡éƒ¨åˆ†](#æœªå®Œæˆè·³è¿‡éƒ¨åˆ†)
- [C++åŸºç¡€](#cåŸºç¡€)
  - [å£°æ˜ï¼Œå®šä¹‰ï¼Œåˆå§‹åŒ–ï¼Œèµ‹å€¼](#å£°æ˜å®šä¹‰åˆå§‹åŒ–èµ‹å€¼)
    - [1. å£°æ˜ï¼ˆDeclarationï¼‰](#1-å£°æ˜declaration)
    - [2. å®šä¹‰ï¼ˆDefinitionï¼‰](#2-å®šä¹‰definition)
    - [3. åˆå§‹åŒ–ï¼ˆInitializationï¼‰](#3-åˆå§‹åŒ–initialization)
    - [4.èµ‹å€¼ï¼ˆAssignmentï¼‰](#4èµ‹å€¼assignment)
  - [decltype()](#decltype)
  - [void\* æŒ‡é’ˆ](#void-æŒ‡é’ˆ)
  - [`union`](#union)
  - [`restrict`å…³é”®å­—ï¼ˆcè¯­è¨€ï¼‰](#restrictå…³é”®å­—cè¯­è¨€)
  - [functional](#functional)
  - [lambdaè¡¨è¾¾å¼](#lambdaè¡¨è¾¾å¼)
- [æ™ºèƒ½æŒ‡é’ˆ](#æ™ºèƒ½æŒ‡é’ˆ)
  - [`std::shared_ptr`](#stdshared_ptr)
- [class ç›¸å…³ï¼š](#class-ç›¸å…³)
  - [staticå…³é”®å­—](#staticå…³é”®å­—)
  - [explicitå…³é”®å­—](#explicitå…³é”®å­—)
  - [ææ„å‡½æ•°](#ææ„å‡½æ•°)
  - [`::`è¿ç®—ç¬¦](#è¿ç®—ç¬¦)
  - [`const`ä¿®é¥°æˆå‘˜å‡½æ•°](#constä¿®é¥°æˆå‘˜å‡½æ•°)
- [C++æ¨¡æ¿ç¼–ç¨‹](#cæ¨¡æ¿ç¼–ç¨‹)
  - [ç±»å‹æ¨¡æ¿å‚æ•°](#ç±»å‹æ¨¡æ¿å‚æ•°)
  - [éç±»å‹æ¨¡æ¿å‚æ•°](#éç±»å‹æ¨¡æ¿å‚æ•°)
  - [æ¨¡æ¿ç¼–è¯‘](#æ¨¡æ¿ç¼–è¯‘)
  - [ä¾èµ–ç±»å‹](#ä¾èµ–ç±»å‹)
  - [éƒ¨åˆ†ç‰¹åŒ–ï¼ˆåç‰¹åŒ–ï¼‰ï¼ˆPartial Specializationï¼‰](#éƒ¨åˆ†ç‰¹åŒ–åç‰¹åŒ–partial-specialization)
  - [SFINAEæœºåˆ¶ï¼ˆSubstitution Failure Is Not An Errorï¼‰](#sfinaeæœºåˆ¶substitution-failure-is-not-an-error)
- [å·¦å€¼å’Œå³å€¼](#å·¦å€¼å’Œå³å€¼)
- [C++11çš„å¯å˜æ¨¡æ¿å‚æ•°ï¼ˆ`typename... Args`ï¼‰](#c11çš„å¯å˜æ¨¡æ¿å‚æ•°typename-args)
- [::operator newå’Œ::newå’Œmalloc()](#operator-newå’Œnewå’Œmalloc)
- [new(`new T()`)å’Œplacement new(`new(ptr) T()`)](#newnew-tå’Œplacement-newnewptr-t)
- [lvalue reference and rvalue reference and universal reference](#lvalue-reference-and-rvalue-reference-and-universal-reference)
- [`std::forward<T>()` å’Œ `std::move()`](#stdforwardt-å’Œ-stdmove)
  - [`std::forward<T>()`](#stdforwardt)
  - [`std::move()`](#stdmove)
- [memcpy](#memcpy)
- [is\_trivially\_copyable](#is_trivially_copyable)
  - [1. ä»€ä¹ˆæ˜¯ `is_trivially_copyable`ï¼Ÿ](#1-ä»€ä¹ˆæ˜¯-is_trivially_copyable)
  - [2. ä¸ºä»€ä¹ˆ`memcpy`åªèƒ½ç”¨äº`is_trivially_copyable`?](#2-ä¸ºä»€ä¹ˆmemcpyåªèƒ½ç”¨äºis_trivially_copyable)
- [çº¢é»‘æ ‘](#çº¢é»‘æ ‘)
- [C++å¤šçº¿ç¨‹ç¼–ç¨‹](#cå¤šçº¿ç¨‹ç¼–ç¨‹)
  - [C++ å†…å­˜åºï¼ˆMemory Orderï¼‰æ¦‚è¿°](#c-å†…å­˜åºmemory-orderæ¦‚è¿°)
    - [ä¸ºä»€ä¹ˆéœ€è¦å†…å­˜åºï¼Ÿ](#ä¸ºä»€ä¹ˆéœ€è¦å†…å­˜åº)
    - [å¸¸è§çš„å‡ ç§å†…å­˜åº](#å¸¸è§çš„å‡ ç§å†…å­˜åº)
    - [å¦‚ä½•é€‰æ‹©åˆé€‚çš„å†…å­˜åºï¼Ÿ](#å¦‚ä½•é€‰æ‹©åˆé€‚çš„å†…å­˜åº)
    - [æ€»ç»“](#æ€»ç»“)
  - [`std::mutex`](#stdmutex)
    - [åŸºæœ¬ä½¿ç”¨](#åŸºæœ¬ä½¿ç”¨)
    - [ä½¿ç”¨RAIIæ–¹å¼åŠ é”è§£é”](#ä½¿ç”¨raiiæ–¹å¼åŠ é”è§£é”)
  - [`std::condtion_variable`](#stdcondtion_variable)
    - [åŸºæœ¬åŸç†](#åŸºæœ¬åŸç†)
    - [æ ¸å¿ƒå‡½æ•°](#æ ¸å¿ƒå‡½æ•°)
    - [å…¸å‹æ¡ˆä¾‹ï¼šç”Ÿäº§è€…-æ¶ˆè´¹è€…](#å…¸å‹æ¡ˆä¾‹ç”Ÿäº§è€…-æ¶ˆè´¹è€…)
  - [`std::future`](#stdfuture)

# æ”¶è·
1. ä½¿ç”¨Address Sanitizer(ASan)æ£€æŸ¥å‡ºå†…å­˜é”™è¯¯ï¼š
   åœ¨å†™vectorçš„æ—¶å€™ï¼Œè°ƒç”¨é…ç½®å™¨çš„allocateå’Œdeallocateçš„æ—¶å€™å‡ºç°äº†é—®é¢˜ï¼Œä½¿ç”¨ASanå‘ç°åˆ é™¤çš„å†…å­˜æ¯”åˆ†é…çš„å†…å­˜æ›´å¤šã€‚æ£€æµ‹åå‘ç°vectorçš„`size()`å’Œ`capacity()`æœ‰é—®é¢˜ã€‚

# æœªå®Œæˆè·³è¿‡éƒ¨åˆ†
1. ï¼ˆå·²å®Œæˆï¼‰std::forward()å®Œç¾è½¬å‘å®ç°ï¼Œåœ¨`construct.h`å’Œ`allocator.h`ä¸­è°ƒç”¨`std::forward()`
2. ï¼ˆå·²å®Œæˆï¼‰std::move(), åœ¨`allocator.h`ä¸­è°ƒç”¨`std::move()`
3.  (å·²å®Œæˆ) å®¹å™¨ä¸­è°ƒç”¨äº†`<memory>`çš„ç›¸å…³æ“ä½œã€‚
   - `relloc_and_insert`ä¸­çš„`std::uninitialized_move`

# C++åŸºç¡€

## å£°æ˜ï¼Œå®šä¹‰ï¼Œåˆå§‹åŒ–ï¼Œèµ‹å€¼
### 1. å£°æ˜ï¼ˆDeclarationï¼‰
   å£°æ˜çš„ä½œç”¨æ˜¯å‘Šè¯‰ç¼–è¯‘å™¨æŸä¸ªå®ä½“çš„å­˜åœ¨åŠå…¶ç±»å‹ï¼Œä½†ä¸ä¼šåˆ†é…å†…å­˜æˆ–æä¾›å…·ä½“çš„å®ç°ã€‚å£°æ˜é€šå¸¸ç”¨äºå˜é‡ã€å‡½æ•°ã€ç±»ã€æ¨¡æ¿ç­‰ã€‚
   - å˜é‡å£°æ˜ï¼šå‘Šè¯‰ç¼–è¯‘å™¨å˜é‡çš„ç±»å‹å’Œåç§°ï¼Œä½†ä¸åˆ†é…å†…å­˜ã€‚
  ```
    extern int x;   //å£°æ˜ä¸€ä¸ªæ•´å‹å˜é‡xï¼Œä½†ä¸å®šä¹‰ä»–ä¹Ÿä¸åˆ†é…å†…å­˜ã€‚
  ```
  è¿™é‡Œçš„`extern`å…³é”®å­—è¡¨ç¤º`x`åœ¨å…¶ä»–åœ°æ–¹å®šä¹‰ã€‚
  - å‡½æ•°å£°æ˜ï¼šå‘Šè¯‰ç¼–è¯‘å™¨å‡½æ•°çš„åç§°ã€è¿”å›ç±»å‹å’Œå‚æ•°åˆ—è¡¨ï¼Œä½†ä¸æä¾›å‡½æ•°ä½“ã€‚
  ```
  int add(int a, int b);    //å£°æ˜ä¸€ä¸ªå‡½æ•°addã€‚
  ```
  - ç±»å£°æ˜ï¼š å‘Šè¯‰ç¼–è¯‘å™¨ç±»çš„åç§°å’Œæˆå‘˜ï¼Œä½†ä¸æä¾›å®ç°ã€‚
  ```
  class Myclass;    //å£°æ˜ä¸€ä¸ªç±»Myclass
  ```
### 2. å®šä¹‰ï¼ˆDefinitionï¼‰
   å®šä¹‰æ˜¯ä¸ºå£°æ˜çš„å®ä½“åˆ†é…å†…å­˜æˆ–æä¾›å…·ä½“å®ç°ã€‚å®šä¹‰æ˜¯å£°æ˜çš„è¶…é›†ï¼Œå³å®šä¹‰åŒ…å«äº†å£°æ˜ã€‚
-  å˜é‡å®šä¹‰ï¼šä¸ºå˜é‡åˆ†é…å†…å­˜å¹¶å¯ä»¥åˆå§‹åŒ–ã€‚
```
int x; // å®šä¹‰ä¸€ä¸ªæ•´å‹å˜é‡xï¼Œåˆ†é…å†…å­˜
```
- å‡½æ•°å®šä¹‰ï¼šæä¾›å‡½æ•°çš„å…·ä½“å®ç°ã€‚
```
int add(int a, int b) {
    return a + b;
}
```
- ç±»å®šä¹‰ï¼šæä¾›ç±»çš„å®Œæ•´å®ç°ï¼ŒåŒ…æ‹¬æˆå‘˜å˜é‡å’Œæˆå‘˜å‡½æ•°ã€‚
```
class MyClass {
public:
    int value;
    void print() {
        std::cout << value << std::endl;
    }
};
```

### 3. åˆå§‹åŒ–ï¼ˆInitializationï¼‰
åˆå§‹åŒ–æ˜¯åœ¨å®šä¹‰å˜é‡æ—¶ä¸ºå…¶èµ‹äºˆä¸€ä¸ªåˆå§‹å€¼ã€‚åˆå§‹åŒ–å¯ä»¥å‘ç”Ÿåœ¨å®šä¹‰æ—¶ï¼Œä¹Ÿå¯ä»¥åœ¨æ„é€ å‡½æ•°ä¸­ã€‚
- ç›´æ¥åˆå§‹åŒ–ï¼š
```
int x = 10; // å®šä¹‰å¹¶åˆå§‹åŒ–xä¸º10
```
- åˆ—è¡¨åˆå§‹åŒ–ï¼ˆC++11å¼•å…¥ï¼‰ï¼š
```
int x{10}; // ä½¿ç”¨èŠ±æ‹¬å·åˆå§‹åŒ–
```
- é»˜è®¤åˆå§‹åŒ–ï¼š
å¦‚æœæ²¡æœ‰æ˜¾å¼åˆå§‹åŒ–ï¼Œå˜é‡ä¼šè¢«é»˜è®¤åˆå§‹åŒ–ã€‚å¯¹äºå†…ç½®ç±»å‹ï¼ˆå¦‚ intï¼‰ï¼Œé»˜è®¤åˆå§‹åŒ–å¯èƒ½æ˜¯æœªå®šä¹‰çš„ï¼ˆåƒåœ¾å€¼ï¼‰ï¼›å¯¹äºç±»ç±»å‹ï¼Œä¼šè°ƒç”¨é»˜è®¤æ„é€ å‡½æ•°ã€‚
```
int x; // é»˜è®¤åˆå§‹åŒ–ï¼Œxçš„å€¼æœªå®šä¹‰
```
- æ„é€ å‡½æ•°åˆå§‹åŒ–ï¼š
å¯¹äºç±»å¯¹è±¡ï¼Œåˆå§‹åŒ–é€šå¸¸é€šè¿‡æ„é€ å‡½æ•°å®Œæˆã€‚
```
class MyClass {
public:
    int value;
    MyClass(int v) : value(v) {} // æ„é€ å‡½æ•°åˆå§‹åŒ–åˆ—è¡¨
};
```

### 4.èµ‹å€¼ï¼ˆAssignmentï¼‰
èµ‹å€¼æ˜¯ä¸ºå·²ç»å®šä¹‰çš„å˜é‡èµ‹äºˆä¸€ä¸ªæ–°å€¼ã€‚

## decltype()
ç”¨äºè·å–å˜é‡æˆ–è¡¨è¾¾å¼çš„ç±»å‹
```
int x = 10;
decltype(x) y = 20;  // `y` çš„ç±»å‹æ˜¯ `int`

int a = 10, b = 20;
decltype(a + b) c = 30;  // `c` çš„ç±»å‹æ˜¯ `int`
```
`decltype((expr))` ä¸ `decltype(expr)` çš„åŒºåˆ«
```
int x = 10;
decltype(x) a = x;   // `a` æ˜¯ `int`
decltype((x)) b = x; // `b` æ˜¯ `int&`
```

## void* æŒ‡é’ˆ
`void*`æ˜¯ "æ— ç±»å‹æŒ‡é’ˆ"ï¼ˆvoid pointerï¼‰ï¼Œè¡¨ç¤ºå®ƒå¯ä»¥æŒ‡å‘ä»»ä½•ç±»å‹çš„æ•°æ®ã€‚åœ¨ C å’Œ C++ è¯­è¨€ä¸­ï¼Œå®ƒè¢«å¹¿æ³›ç”¨äºæ³›å‹ç¼–ç¨‹ã€åŠ¨æ€å†…å­˜ç®¡ç†å’Œä¸åº•å±‚ APIï¼ˆå¦‚ `malloc()` å’Œ `free()`ï¼‰äº¤äº’ã€‚

1. `void*`çš„ç‰¹ç‚¹
   - **ä¸èƒ½ç›´æ¥è§£å¼•ç”¨**ï¼šç”±äº`void*`æ²¡æœ‰å…·ä½“ç±»å‹ï¼Œä¸èƒ½ç›´æ¥é€šè¿‡`*ptr`è®¿é—®å€¼ï¼Œå¿…é¡»å…ˆè½¬æ¢æˆåˆé€‚çš„ç±»å‹ã€‚
   - **å¯ä»¥è½¬æ¢ä¸ºä»»ä½•æŒ‡é’ˆ**ï¼š ä»»ä½•æŒ‡é’ˆç±»å‹éƒ½å¯ä»¥è½¬æ¢æˆ`void*`,åä¹‹äº¦ç„¶ï¼ˆéœ€è¦æ˜¾ç¤ºè½¬æ¢ï¼‰ã€‚
   - **å¸¸ç”¨äºé€šç”¨å‡½æ•°**ï¼šä¾‹å¦‚`malloc()`è¿”å›`void*`ï¼Œå› ä¸ºå®ƒåˆ†é…çš„å†…å­˜å¯ä»¥å­˜å‚¨ä»»ä½•ç±»å‹çš„æ•°æ®ã€‚

## `union`
åœ¨ C++ ä¸­ï¼Œ`union`ï¼ˆè”åˆä½“ï¼‰æ˜¯ä¸€ç§ç‰¹æ®Šçš„ æ•°æ®ç»“æ„ï¼Œå®ƒå…è®¸ å¤šä¸ªå˜é‡å…±ç”¨åŒä¸€å—å†…å­˜ã€‚`union` ç±»ä¼¼äº `struct`ï¼Œä½†æ‰€æœ‰æˆå‘˜å…±äº«åŒä¸€å—å†…å­˜åŒºåŸŸï¼Œå› æ­¤å®ƒçš„å¤§å°å–å†³äº æœ€å¤§çš„æˆå‘˜å˜é‡ã€‚

```c
#include <iostream>

union Data {
    int i;
    float f;
    char c;
};

int main() {
    Data d;
    d.i = 42;
    std::cout << "æ•´æ•° i: " << d.i << std::endl;

    d.f = 3.14f;
    std::cout << "æµ®ç‚¹æ•° f: " << d.f << std::endl;

    d.c = 'A';
    std::cout << "å­—ç¬¦ c: " << d.c << std::endl;

    std::cout << "å†æ¬¡è®¿é—® i: " << d.i << std::endl; // âš ï¸ å¯èƒ½è¢«è¦†ç›–
}
```
ç»“æœï¼š
```c
æ•´æ•° i: 42
æµ®ç‚¹æ•° f: 3.14
å­—ç¬¦ c: A
å†æ¬¡è®¿é—® i: 1094795585  // âš ï¸ i çš„å€¼è¢« f è¦†ç›–
```

- `union`çš„æ‰€æœ‰æˆå‘˜å…±äº«ä¸€å—å†…å­˜ï¼Œä¿®æ”¹ä¸€ä¸ªæˆå‘˜ï¼Œä¼šè¦†ç›–å…¶ä»–æˆå‘˜ã€‚
- `union` å¤§å°ç­‰äºæœ€å¤§æˆå‘˜çš„å¤§å°ï¼ˆå¯¹é½æ—¶å¯èƒ½ç¨å¤§ï¼‰ã€‚
- `union` åªèƒ½å­˜å‚¨ä¸€ä¸ªå€¼ï¼Œå› ä¸ºå¤šä¸ªæˆå‘˜å…±ç”¨åŒä¸€å—å†…å­˜ã€‚

## `restrict`å…³é”®å­—ï¼ˆcè¯­è¨€ï¼‰
restrict æ˜¯ C è¯­è¨€ä¸­çš„ç±»å‹é™å®šç¬¦ï¼Œç”¨äºæŒ‡é’ˆï¼Œè¡¨ç¤ºè¯¥æŒ‡é’ˆæ˜¯è®¿é—®æŸå—å†…å­˜çš„å”¯ä¸€æ–¹å¼ã€‚å®ƒå‘Šè¯‰ç¼–è¯‘å™¨ä¸ä¼šé€šè¿‡å…¶ä»–æŒ‡é’ˆè®¿é—®ç›¸åŒçš„å†…å­˜ï¼Œä»è€Œå…è®¸ç¼–è¯‘å™¨ä¼˜åŒ–ä»£ç ï¼Œæé«˜æ€§èƒ½ã€‚

restrict å…³é”®å­—æ˜¯ C99 æ ‡å‡†å¼•å…¥çš„ï¼ŒC++ æ²¡æœ‰åŸç”Ÿæ”¯æŒï¼ˆä½†ä¸€äº›ç¼–è¯‘å™¨æä¾›æ‰©å±•ï¼Œå¦‚ \_\_restrict\_\_ æˆ– __restrictï¼‰ã€‚

ä¾‹å¦‚ï¼š
```c
void copy(int *restrict dest, const int *restrict src, size_t n) {
    for (size_t i = 0; i < n; i++) {
        dest[i] = src[i];  // ç¼–è¯‘å™¨å¯ä»¥ä¼˜åŒ–
    }
}
```

`restrict`å‘Šè¯‰ç¼–è¯‘å™¨`dest`å’Œ`src`æŒ‡å‘çš„å†…å­˜åŒºåŸŸä¸ä¼šé‡å ï¼Œä»£ç å¯ä»¥å®‰å…¨åœ°ä¼˜åŒ–ï¼Œæ¯”å¦‚å‘é‡åŒ–ï¼ˆSIMDï¼‰

## functional
std::function<void()> ä»£è¡¨æ— å‚æ•°ä¸”æ— è¿”å›å€¼çš„å‡½æ•°ç­¾åï¼Œå› æ­¤ä¸èƒ½ç›´æ¥æ¥å—ä¸€ä¸ªæœ‰å‚æ•°çš„å‡½æ•°æŒ‡é’ˆã€‚ä½†å¯ä»¥é€šè¿‡ç»‘å®šå‚æ•°çš„æ–¹å¼ï¼Œä½¿å…¶é€‚é… std::function<void()>ã€‚

```c
#include <iostream>
#include <functional>

void myFunc(int x) {
    std::cout << "Value: " << x << std::endl;
}

int main() {
    std::function<void()> func = std::bind(myFunc, 42);  // ç»‘å®šå‚æ•° x=42
    func();  // è¾“å‡º "Value: 42"
    return 0;
}
```

## lambdaè¡¨è¾¾å¼
Lambda è¡¨è¾¾å¼çš„åŸºæœ¬è¯­æ³•å¦‚ä¸‹ï¼š
```
[æ•è·åˆ—è¡¨](å‚æ•°åˆ—è¡¨) -> è¿”å›ç±»å‹ { å‡½æ•°ä½“ };
```
å…¶ä¸­ï¼š
- æ•è·åˆ—è¡¨ [ ]ï¼šå®šä¹‰ lambda å¦‚ä½•æ•è·å¤–éƒ¨å˜é‡ï¼ˆå€¼æ•è· =ï¼Œå¼•ç”¨æ•è· &ï¼‰ã€‚
- å‚æ•°åˆ—è¡¨ ( )ï¼šç±»ä¼¼æ™®é€šå‡½æ•°çš„å‚æ•°åˆ—è¡¨ï¼ˆå¯ä»¥çœç•¥ï¼‰ã€‚
- è¿”å›ç±»å‹ ->ï¼ˆå¯é€‰ï¼‰ï¼šå¯ä»¥çœç•¥ï¼Œç¼–è¯‘å™¨ä¼šè‡ªåŠ¨æ¨å¯¼ã€‚
- å‡½æ•°ä½“ {}ï¼šå®é™…çš„ä»£ç é€»è¾‘ã€‚

```c
#include <iostream>

int main() {
    auto add = [](int a, int b) { return a + b; };
    std::cout << "3 + 5 = " << add(3, 5) << std::endl; // è¾“å‡º 8
    return 0;
}
```  

```c
#include <iostream>

int main() {
    auto divide = [](double a, double b) -> double {
        if (b == 0) return 0;
        return a / b;
    };
    std::cout << "10 / 3 = " << divide(10, 3) << std::endl; // è¾“å‡º 3.33333
    return 0;
}
```

1. å€¼æ•è·`[=]`ï¼ˆæ‹·è´ï¼‰
å€¼æ•è·ä¼š æ‹·è´ å˜é‡ï¼Œå› æ­¤åœ¨ Lambda å†…éƒ¨ä¿®æ”¹å˜é‡ä¸ä¼šå½±å“å¤–éƒ¨ã€‚
```c
#include <iostream>

int main() {
    int x = 10;
    auto lambda = [=]() { std::cout << "x = " << x << std::endl; };
    lambda();
    return 0;
}
```

2. å¼•ç”¨æ•è·`[&]`ï¼ˆå¼•ç”¨ï¼‰
```c
#include <iostream>

int main() {
    int x = 10;
    auto lambda = [&]() { x += 5; };
    lambda();
    std::cout << "x = " << x << std::endl; // è¾“å‡º 15
    return 0;
}
```

3. æŒ‡å®šæ•è·å˜é‡
```c
#include <iostream>

int main() {
    int a = 10, b = 20;
    auto lambda = [a, &b]() {
        // a è¢«å€¼æ•è·ï¼Œæ— æ³•ä¿®æ”¹
        // b è¢«å¼•ç”¨æ•è·ï¼Œå¯ä»¥ä¿®æ”¹
        // a += 5; // âŒ ç¼–è¯‘é”™è¯¯
        b += 5;   // âœ… å¯ä»¥ä¿®æ”¹
    };

    lambda();
    std::cout << "a = " << a << ", b = " << b << std::endl; // a = 10, b = 25
    return 0;
}
```

# æ™ºèƒ½æŒ‡é’ˆ

## `std::shared_ptr`
åœ¨ C++ ä¸­ï¼Œ`std::shared_ptr` æ˜¯ä¸€ä¸ªé‡‡ç”¨å¼•ç”¨è®¡æ•°ï¼ˆReference Countingï¼‰ç­–ç•¥çš„æ™ºèƒ½æŒ‡é’ˆï¼Œå…¶æ ¸å¿ƒæ€æƒ³æ˜¯â€œå½“æœ€åä¸€ä¸ªæŒ‡é’ˆç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œæ‰çœŸæ­£é‡Šæ”¾èµ„æºï¼ˆå†…å­˜ã€æ–‡ä»¶ç­‰ï¼‰â€ã€‚ä»æºç æˆ–å®ç°ç»†èŠ‚çš„è§’åº¦æ¥çœ‹ï¼Œ`std::shared_ptr` å¤§ä½“ä¸Šå¯åˆ†ä¸ºä»¥ä¸‹å‡ ä¸ªå…³é”®ç‚¹ï¼š
1. æ§åˆ¶å—ï¼ˆControl Blockï¼‰
   - å½“ä½ ç”¨ `std::shared_ptr` ç®¡ç†ä¸€å—å †ä¸Šåˆ†é…çš„å¯¹è±¡æ—¶ï¼Œè¿è¡Œåº“ï¼ˆStandard Library Implementationï¼‰é€šå¸¸ä¼šåœ¨å †ä¸Šé¢å¤–åˆ›å»ºä¸€ä¸ªâ€œæ§åˆ¶å—â€æ¥ç®¡ç†è¿™å—èµ„æºçš„å¼•ç”¨è®¡æ•°ä¿¡æ¯å’Œå…¶ä»–å¿…è¦çš„å…ƒæ•°æ®ï¼ˆå¦‚è‡ªå®šä¹‰åˆ é™¤å™¨ã€ç±»å‹æ“¦é™¤ç”¨çš„æŒ‡é’ˆç­‰ï¼‰ã€‚
    - æ§åˆ¶å—åŒ…å«ï¼š
       - use_countï¼šå…±äº«è®¡æ•°ï¼Œç”¨äºç»Ÿè®¡æœ‰å¤šå°‘ä¸ª shared_ptr åœ¨ç®¡ç†åŒä¸€ä¸ªå¯¹è±¡ï¼›
       - weak_countï¼šå¼±è®¡æ•°ï¼Œç”¨äºç»Ÿè®¡æœ‰å¤šå°‘ä¸ª weak_ptr ä¸è¿™ä¸ªå¯¹è±¡ç›¸å…³è”ï¼ˆä¸å½±å“å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸï¼‰ï¼›
       - deleterï¼šè‡ªå®šä¹‰åˆ é™¤å™¨ï¼Œæˆ–è€…é»˜è®¤åˆ é™¤å™¨ï¼ˆè°ƒç”¨ deleteï¼‰ï¼Œå½“ use_count å½’é›¶æ—¶è°ƒç”¨ï¼›
       - æŒ‡å‘å®é™…å¯¹è±¡çš„æŒ‡é’ˆï¼ˆæœ‰æ—¶è¿™ä¸ªæŒ‡é’ˆå’Œ shared_ptr å†…éƒ¨é‚£ä¸ªæŒ‡é’ˆä¸æ˜¯åŒä¸€ä¸ªä¸œè¥¿ï¼Œå–å†³äºå®ç°ï¼‰ã€‚
   - å½“æˆ‘ä»¬è°ƒç”¨ make_shared<T>(...) æ—¶ï¼ŒC++ å®ç°é€šå¸¸ä¼šå°† T å¯¹è±¡ä¸æ§åˆ¶å—ä¸€èµ·â€œæ‰“åŒ…â€åˆ†é…åœ¨åŒä¸€å—è¿ç»­å†…å­˜é‡Œï¼Œä»è€Œå‡å°‘ä¸€æ¬¡å†…å­˜åˆ†é…ã€‚
```cpp
// ç®€åŒ–ç‰ˆçš„â€œæ§åˆ¶å—â€ç»“æ„
struct shared_count
{
    std::atomic<long> use_count;  // å…±äº«è®¡æ•°
    std::atomic<long> weak_count; // å¼±è®¡æ•° (æœ¬ä¾‹å­ä¸­æ²¡å®Œæ•´æ¼”ç¤º weak_ptr)

    // æ„é€ æ—¶ï¼Œä¸€èˆ¬è®© use_count=1ï¼Œweak_count=1ï¼ˆå…¼å®¹ future weak_ptrï¼‰
    shared_count() : use_count(1), weak_count(1) {}

    // å¢åŠ å…±äº«å¼•ç”¨è®¡æ•°
    void add_ref_copy() {
        use_count.fetch_add(1, std::memory_order_relaxed);
    }

    // é‡Šæ”¾ä¸€ä¸ªå…±äº«å¼•ç”¨ï¼Œè¿”å›é‡Šæ”¾åå‰©ä½™çš„å…±äº«è®¡æ•°
    long release() {
        // fetch_sub è¿”å›çš„æ˜¯â€œå‡å°‘å‰â€çš„å€¼ï¼Œæ‰€ä»¥è¦-1
        return use_count.fetch_sub(1, std::memory_order_acq_rel) - 1;
    }

    // å¢åŠ ä¸€ä¸ªå¼±å¼•ç”¨ï¼ˆæ¼”ç¤ºç”¨ï¼‰
    void weak_add_ref() {
        weak_count.fetch_add(1, std::memory_order_relaxed);
    }

    // é‡Šæ”¾ä¸€ä¸ªå¼±å¼•ç”¨ï¼Œå¹¶è¿”å›é‡Šæ”¾åçš„å¼±è®¡æ•°
    long weak_release() {
        return weak_count.fetch_sub(1, std::memory_order_acq_rel) - 1;
    }
};
```


2. `shared_ptr`æœ¬èº«çš„å†…å­˜ç»“æ„ï¼š
    - `shared_ptr`é€šå¸¸åªåŒ…æ‹¬ä¸¤ä¸ªæŒ‡é’ˆæˆå‘˜  
       1. px: æŒ‡å‘æ‰€ç®¡ç†å¯¹è±¡çš„æŒ‡é’ˆï¼ˆå¯èƒ½æ˜¯åŸå§‹æŒ‡é’ˆï¼Œä¹Ÿå¯èƒ½æ˜¯æŸç§ç±»å‹æ“¦é™¤è¿‡çš„æŒ‡é’ˆï¼Œè§†å…·ä½“å®ç°è€Œå®šï¼‰ã€‚
       2. pnï¼šæŒ‡å‘ä¸Šè¿°æ§åˆ¶å—çš„æŒ‡é’ˆã€‚
    - æ¯å½“æˆ‘ä»¬æ‹·è´ä¸€ä¸ª `shared_ptr` æ—¶ï¼Œå°±ä¼šæŠŠä¸¤ä¸ªæŒ‡é’ˆéƒ½æ‹·è´ä¸€éï¼Œå¹¶æŠŠæ§åˆ¶å—ä¸­çš„ `use_count` åŸå­åœ°åŠ  1ï¼›å½“é”€æ¯ä¸€ä¸ª `shared_ptr`  æ—¶ï¼Œå°±ä¼šæŠŠ `use_count` åŸå­åœ°å‡ 1ï¼Œå¹¶æ£€æŸ¥æ˜¯å¦å½’é›¶ã€‚
```cpp
// éå¸¸ç®€åŒ–çš„ shared_ptr
template<typename T>
class shared_ptr
{
private:
    T* px;               // æŒ‡å‘å®é™…å¯¹è±¡
    shared_count* pn;    // æŒ‡å‘æ§åˆ¶å—

public:
    // 1. é»˜è®¤æ„é€ ï¼šç©ºæŒ‡é’ˆï¼Œç©ºæ§åˆ¶å—
    shared_ptr() : px(nullptr), pn(nullptr) {}

    // 2. é€šè¿‡åŸå§‹æŒ‡é’ˆæ„é€ 
    explicit shared_ptr(T* p) : px(p) {
        // åˆ†é…ä¸€ä¸ªæ–°çš„æ§åˆ¶å—ï¼Œuse_count = 1ï¼Œweak_count = 1
        pn = new shared_count();
    }

    // 3. æ‹·è´æ„é€ 
    shared_ptr(const shared_ptr& other)
    {
        px = other.px;
        pn = other.pn;
        // å¼•ç”¨è®¡æ•°+1
        if (pn) {
            pn->add_ref_copy();
        }
    }

    // 4. æ‹·è´èµ‹å€¼
    shared_ptr& operator=(const shared_ptr& other)
    {
        // è‡ªæˆ‘èµ‹å€¼ä¿æŠ¤
        if (this != &other) {
            // å…ˆæŠŠè‡ªå·±åŸæ¥çš„èµ„æºé‡Šæ”¾æ‰
            if (pn) {
                // release() è¿”å›å€¼æ˜¯ â€œå‡å°‘åçš„ use_countâ€
                if (pn->release() == 0) {
                    delete px; // é‡Šæ”¾å®é™…å¯¹è±¡
                    px = nullptr;
                    // å½“ use_count == 0 åï¼Œå†è®© weak_count ä¹Ÿå‡ 1
                    if (pn->weak_release() == 0) {
                        delete pn; // å½“ weak_count ä¹Ÿä¸º 0 æ—¶ï¼Œé‡Šæ”¾æ§åˆ¶å—
                    }
                }
            }
            // å†æ¥ç®¡ new è¿›æ¥çš„èµ„æº
            px = other.px;
            pn = other.pn;
            // å¼•ç”¨è®¡æ•°+1
            if (pn) {
                pn->add_ref_copy();
            }
        }
        return *this;
    }

    // 5. ææ„å‡½æ•°
    ~shared_ptr()
    {
        if (pn) {
            // å‡å°‘ä¸€ä¸ªå…±äº«å¼•ç”¨
            if (pn->release() == 0) {
                // è¯´æ˜è¿™æ˜¯æœ€åä¸€ä¸ªå…±äº«æŒ‡é’ˆï¼Œé‡Šæ”¾èµ„æº
                delete px;
                px = nullptr;
                // å‡å°‘ä¸€ä¸ªå¼±å¼•ç”¨ï¼›è‹¥å¼±å¼•ç”¨ä¹Ÿä¸º 0ï¼Œåˆ™é‡Šæ”¾æ§åˆ¶å—
                if (pn->weak_release() == 0) {
                    delete pn;
                }
            }
        }
    }

    // å¸¸ç”¨æ¥å£
    T* get() const { return px; }

    // è¿”å›å½“å‰çš„ use_count å€¼
    long use_count() const {
        return pn ? pn->use_count.load(std::memory_order_acquire) : 0;
    }

    // é‡è½½ -> æ“ä½œç¬¦ï¼Œæ–¹ä¾¿ä½¿ç”¨
    T* operator->() const { return px; }

    // é‡è½½ * æ“ä½œç¬¦ï¼Œæ–¹ä¾¿ä½¿ç”¨
    T& operator*()  const { return *px; }
};

```

# class ç›¸å…³ï¼š

<img src="./picture/p1.jpg" alt="implict_methods" width="600"/>
<img src="./picture/p2.png" alt="implict_methods" width="600"/>

## staticå…³é”®å­—
static å…³é”®å­—ç”¨äºå£°æ˜é™æ€æˆå‘˜å‡½æ•°ã€‚é™æ€æˆå‘˜å‡½æ•°çš„ç‰¹ç‚¹æ˜¯ä¸ä¾èµ–äºå…·ä½“çš„ç±»å®ä¾‹ï¼Œå¯ä»¥ç›´æ¥é€šè¿‡ç±»åè°ƒç”¨ã€‚  

é™æ€å‡½æ•°çš„é™åˆ¶ï¼š  
1. æ²¡æœ‰ this æŒ‡é’ˆ  
é™æ€æˆå‘˜å‡½æ•°ä¸èƒ½è®¿é—®ç±»çš„éé™æ€æˆå‘˜å˜é‡æˆ–å‡½æ•°ï¼Œå› ä¸ºå®ƒä»¬æ²¡æœ‰ this æŒ‡é’ˆã€‚

2. ä¸èƒ½è¢«è™šå‡½æ•°è¦†ç›–
é™æ€æˆå‘˜å‡½æ•°æ— æ³•å£°æ˜ä¸ºè™šå‡½æ•°ï¼Œå› ä¸ºå®ƒä»¬ä¸ä¾èµ–äºå…·ä½“å¯¹è±¡ã€‚

## explicitå…³é”®å­—
åœ¨ C++ ä¸­ï¼Œ`explicit` å…³é”®å­—ç”¨äºé˜²æ­¢éšå¼ç±»å‹è½¬æ¢ï¼Œä¸»è¦ç”¨äºæ„é€ å‡½æ•°ï¼Œé˜²æ­¢ç¼–è¯‘å™¨åœ¨ä¸æ˜ç¡®çš„æƒ…å†µä¸‹è‡ªåŠ¨æ‰§è¡Œç±»å‹è½¬æ¢ã€‚

## ææ„å‡½æ•°
ææ„å‡½æ•°(`~ClassName()`)æ˜¯C++ç±»ä¸­ä¸€ä¸ªç‰¹æ®Šæˆå‘˜å‡½æ•°ï¼Œå®ƒåœ¨å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸç»“æŸæ—¶è‡ªåŠ¨è°ƒç”¨ï¼Œç”¨äºé‡Šæ”¾èµ„æºï¼Œä¾‹å¦‚æ–‡ä»¶ï¼Œé”ï¼Œç½‘ç»œè¿æ¥ç­‰ã€‚  
æ³¨æ„ï¼š ææ„å‡½æ•°åªè´Ÿè´£æ¸…ç†å¯¹è±¡çš„èµ„æºï¼Œä¸ä¼šè´Ÿè´£é‡Šæ”¾å¯¹è±¡æœ¬èº«çš„å†…å­˜ã€‚  
`delete()`å‡½æ•°å…ˆè°ƒç”¨ç±»çš„ææ„å‡½æ•°ï¼Œç„¶åå†è°ƒç”¨`operator delete()`é‡Šæ”¾å¯¹è±¡çš„å†…å­˜ã€‚

## `::`è¿ç®—ç¬¦
| **è®¿é—®å†…å®¹**           | **èƒ½å¦ç”¨ `::` è®¿é—®ï¼Ÿ** | **ç¤ºä¾‹** |
|-------------------|-----------------|----------------------------|
| **é™æ€æˆå‘˜å˜é‡**  | âœ… å¯ä»¥ | `ClassName::staticVar` |
| **é™æ€æˆå‘˜å‡½æ•°**  | âœ… å¯ä»¥ | `ClassName::staticFunc()` |
| **ç±»å†… `typedef` æˆ– `using`** | âœ… å¯ä»¥ | `ClassName::TypeAlias` |
| **æšä¸¾æˆå‘˜**      | âœ… å¯ä»¥ | `ClassName::EnumValue` |
| **éé™æ€æˆå‘˜å˜é‡** | âŒ ä¸èƒ½ | `ClassName::memberVar`ï¼ˆé”™è¯¯ï¼‰ |
| **éé™æ€æˆå‘˜å‡½æ•°** | âŒ ä¸èƒ½ | `ClassName::memberFunc()`ï¼ˆé”™è¯¯ï¼‰ |

## `const`ä¿®é¥°æˆå‘˜å‡½æ•°
`const`ä¿®é¥°çš„æˆå‘˜å‡½æ•°ä¸èƒ½ä¿®æ”¹ç±»çš„æˆå‘˜å˜é‡ï¼Œé™¤éè¯¥å˜é‡ä½¿ç”¨äº†`mutable`å…³é”®å­—ã€‚æœ¬è´¨ä¸Šæ˜¯ä½œç”¨åœ¨æŒ‡é’ˆ`this`ä¸Šã€‚  
`const`å¯¹è±¡åªèƒ½è°ƒç”¨`const`å‡½æ•°ã€‚  
`const`ä¿®é¥°å¯ä»¥é‡è½½å‡½æ•°ï¼Œ`const`æˆå‘˜ä¼šè°ƒç”¨é‡è½½çš„å‡½æ•°ã€‚

# C++æ¨¡æ¿ç¼–ç¨‹

## ç±»å‹æ¨¡æ¿å‚æ•°
```
template <typename T>
int compare (const T &vl, const T &v2)
{
    if (vl < v2) return -1;
    if (v2 < v1) return 1;
    return 0;
}
```
**å®ä¾‹åŒ–å‡½æ•°æ¨¡æ¿ï¼š**  
å½“æˆ‘ä»¬è°ƒç”¨ä¸€ä¸ªå‡½æ•°æ¨¡æ¿æ—¶,ç¼–è¯‘å™¨(é€šå¸¸)ç”¨å‡½æ•°å®å‚æ¥ä¸ºæˆ‘ä»¬æ¨æ–­æ¨¡æ¿å®å‚ã€‚å³,
å½“æˆ‘ä»¬è°ƒç”¨ compare æ—¶,ç¼–è¯‘å™¨ä½¿ç”¨å®å‚çš„ç±»å‹æ¥ç¡®å®šç»‘å®šåˆ°æ¨¡æ¿å‚æ•°çš„ç±»å‹ã€‚ä¾‹å¦‚,
åœ¨ä¸‹é¢çš„è°ƒç”¨ä¸­:
```
cout << compare (1, 0) << endl; // Tä¸ºint
```
å®å‚ç±»å‹æ˜¯intã€‚ç¼–è¯‘å™¨ä¼šæ¨æ–­å‡ºæ¨¡æ¿å®å‚ä¸ºint,å¹¶å°†å®ƒç»‘å®šåˆ°æ¨¡æ¿å‚æ•°ã€‚
ç¼–è¯‘å™¨ç”¨æ¨æ–­å‡ºçš„æ¨¡æ¿å‚æ•°æ¥ä¸ºæˆ‘ä»¬å®ä¾‹åŒ–(instantiate)ä¸€ä¸ªç‰¹å®šç‰ˆæœ¬çš„å‡½æ•°ã€‚å½“ç¼–
è¯‘å™¨å®ä¾‹åŒ–ä¸€ä¸ªæ¨¡æ¿æ—¶,å®ƒä½¿ç”¨å®é™…çš„æ¨¡æ¿å®å‚ä»£æ›¿å¯¹åº”çš„æ¨¡æ¿å‚æ•°æ¥åˆ›å»ºå‡ºæ¨¡æ¿çš„ä¸€ä¸ª
æ–°â€œå®ä¾‹â€ã€‚

## éç±»å‹æ¨¡æ¿å‚æ•°
```
template<unsigned N, unsigned M>
int compare (const char (&p1) [N], const char (&p2) [M])
{
    return strcmp(p1, p2);
}
```
ä¸€ä¸ªéç±»å‹å‚æ•°å¯ä»¥æ˜¯ä¸€ä¸ªæ•´å‹,æˆ–è€…æ˜¯ä¸€ä¸ªæŒ‡å‘å¯¹è±¡æˆ–å‡½æ•°ç±»å‹çš„æŒ‡é’ˆæˆ–(å·¦å€¼)å¼•ç”¨ã€‚  
åœ¨æ¨¡æ¿å®šä¹‰å†…,æ¨¡æ¿éç±»å‹å‚æ•°æ˜¯ä¸€ä¸ªå¸¸é‡å€¼ã€‚åœ¨éœ€è¦å¸¸é‡è¡¨è¾¾å¼çš„åœ°æ–¹,å¯ä»¥ä½¿ç”¨éç±»å‹å‚æ•°,ä¾‹å¦‚,æŒ‡å®šæ•°ç»„å¤§å°ã€‚

## æ¨¡æ¿ç¼–è¯‘
å½“ç¼–è¯‘å™¨é‡åˆ°ä¸€ä¸ªæ¨¡æ¿å®šä¹‰æ—¶,å®ƒå¹¶ä¸ç”Ÿæˆä»£ç ã€‚åªæœ‰å½“æˆ‘ä»¬å®ä¾‹åŒ–å‡ºæ¨¡æ¿çš„ä¸€ä¸ªç‰¹å®šç‰ˆæœ¬æ—¶,ç¼–è¯‘å™¨æ‰ä¼šç”Ÿæˆä»£ç ã€‚  
ä¹Ÿå°±æ˜¯è¯´åªæœ‰å½“æˆ‘ä»¬ä½¿ç”¨(è€Œä¸æ˜¯å®šä¹‰)æ¨¡æ¿æ—¶,ç¼–è¯‘å™¨æ‰ç”Ÿæˆä»£ç ã€‚

## ä¾èµ–ç±»å‹
```
template <typename T>
void func() {
    T a;                       // ä¸éœ€è¦`typename`
    typename T::value_type x;  // âœ… éœ€è¦ `typename`ï¼Œå› ä¸º `T::value_type` ä¾èµ– `T`
}

```
å½“ç¼–è¯‘å™¨æ— æ³•åœ¨æ¨¡æ¿å®ä¾‹åŒ–ä¹‹å‰ç¡®å®šå®ƒçš„å…·ä½“ç±»å‹ï¼ˆç±»å‹è¿˜æ˜¯å˜é‡ï¼‰æ—¶ï¼Œæˆ‘ä»¬ç§°ä¹‹ä¸ºä¾èµ–ç±»å‹ï¼Œéœ€è¦åœ¨å‰é¢åŠ ä¸Š`typename`æ¥å‘Šè¯‰ç¼–è¯‘å™¨è¿™æ˜¯ä¸ªç±»å‹ã€‚  
åœ¨è¿™ä¸ªä¾‹å­ä¸­`T::value_type`åªæœ‰åœ¨æ¨¡æ¿å®ä¾‹åŒ–çš„æ—¶å€™æ‰èƒ½çŸ¥é“è¿™ä¸ªæ˜¯å˜é‡è¿˜æ˜¯ç±»å‹ï¼Œæ¯”å¦‚ä¸‹é¢è¿™ä¸¤ä¸ªç±»çš„æƒ…å†µã€‚
```
template <typename T>
class Myclass1{
    typedef T value_type;
}

class Myclass2{
    int value_type;
}
```
åœ¨è¿™ä¸ªä¾‹å­ä¸­ï¼Œå¦‚æœ`T`æ˜¯`Myclass1<int>`ï¼Œåˆ™`T::value_type`æ˜¯ä¸€ä¸ªç±»å‹ã€‚  
è€Œå¦‚æœ`T`æ˜¯`Myclass2`ï¼Œåˆ™æ­¤æ—¶`T::value_type`æ˜¯ä¸€ä¸ªå˜é‡ã€‚  
æ‰€ä»¥è¿™ç§æƒ…å†µæˆ‘ä»¬è¦ç”¨`typename`å‘Šè¯‰ç¼–è¯‘å™¨è¿™æ˜¯ä¸€ä¸ªç±»å‹ã€‚  
<br>
åœ¨æˆ‘ä»¬çš„stlå®ç°ä¸­ï¼Œæœ‰è¿™æ ·ä¸€ä¸ªä¾‹å­ï¼š
```
template <typename T>
constexpr T&&
forward(typename std::remove_reference<T>::type& t){
    return static_cast<T&&>(t);
}
```
æˆ‘ä»¬å¯ä»¥çœ‹åˆ°å‚æ•°åˆ—è¡¨ä¸­çš„`std::remove_reference<T>::type& t`å‰é¢ç”¨äº†`typename`  
æ˜¯å› ä¸º`std::remove_reference<T>::type` æ˜¯ä¸€ä¸ª â€œä¾èµ–ç±»å‹ï¼ˆDependent Typeï¼‰â€ï¼Œç¼–è¯‘å™¨åœ¨è§£ææ¨¡æ¿ä»£ç æ—¶æ— æ³•ç¡®å®šå®ƒæ˜¯å¦æ˜¯ä¸€ä¸ªç±»å‹ï¼Œå› æ­¤éœ€è¦ `typename` æ¥æ˜¾å¼æŒ‡å®šã€‚

è¿˜æœ‰ä¸€ä¸ªä¾‹å­ï¼š
```
template <typename T>
constexpr typename mystl::remove_reference<T>::type&& move(T&& t){
    return static_cast<typename mystl::remove_reference<T>::type&&>(t);
}
```
åœ¨è¿™ä¸ªå‡½æ•°çš„è¿”å›ç±»å‹å‰éœ€è¦åŠ ä¸Š`typename`ã€‚å› ä¸ºè¿™ä¸ªè¿”å›ç±»å‹ä¹Ÿæ˜¯ä¸€ä¸ªä¾èµ–ç±»å‹ã€‚

## éƒ¨åˆ†ç‰¹åŒ–ï¼ˆåç‰¹åŒ–ï¼‰ï¼ˆPartial Specializationï¼‰
éƒ¨åˆ†ç‰¹åŒ–ï¼ˆPartial Specializationï¼‰ æ˜¯ C++ æ¨¡æ¿çš„ä¸€ç§é«˜çº§ç‰¹æ€§ï¼Œå®ƒå…è®¸æˆ‘ä»¬å¯¹éƒ¨åˆ†æ¨¡æ¿å‚æ•°è¿›è¡Œç‰¹åŒ–ï¼Œè€Œä¸æ˜¯å®Œå…¨ç‰¹åŒ–æ•´ä¸ªæ¨¡æ¿ã€‚

éƒ¨åˆ†ç‰¹åŒ–çš„æ ¸å¿ƒæ€æƒ³æ˜¯ï¼š
- è®©ä¸»æ¨¡æ¿ å¤„ç†é€šç”¨æƒ…å†µã€‚
- è®©éƒ¨åˆ†ç‰¹åŒ–ç‰ˆæœ¬ ä¼˜åŒ–æˆ–å®šåˆ¶æŸäº›ç‰¹å®šæƒ…å†µã€‚
- éƒ¨åˆ†ç‰¹åŒ–ä¸æ˜¯å…¨ç‰¹åŒ–ï¼ˆå…¨ç‰¹åŒ–è¦æ±‚æ‰€æœ‰æ¨¡æ¿å‚æ•°éƒ½è¢«ç‰¹åŒ–ï¼‰ã€‚
å¸¸è§ç”¨æ³•ï¼š
1. å¤„ç†æŒ‡é’ˆç±»å‹
```
template <typename T>
class TypeTraits {
public:
    static void show() { std::cout << "General type\n"; }
};

// ğŸ¯ ä»…å½“ `T` æ˜¯æŒ‡é’ˆç±»å‹æ—¶ï¼Œä½¿ç”¨æ­¤ç‰¹åŒ–ç‰ˆæœ¬
template <typename T>
class TypeTraits<T*> {
public:
    static void show() { std::cout << "Pointer type\n"; }
};

int main() {
    TypeTraits<int>::show();   // è¾“å‡ºï¼šGeneral type
    TypeTraits<int*>::show();  // è¾“å‡ºï¼šPointer type
}
```

2. å¤„ç†æ•°ç»„ç±»å‹
```
template <typename T>
class TypeTraits {
public:
    static void show() { std::cout << "General type\n"; }
};

// ğŸ¯ ä»…å½“ `T` æ˜¯æ•°ç»„ç±»å‹æ—¶ï¼Œä½¿ç”¨æ­¤ç‰¹åŒ–ç‰ˆæœ¬
template <typename T, size_t N>
class TypeTraits<T[N]> {
public:
    static void show() { std::cout << "Array type\n"; }
};

int main() {
    TypeTraits<int>::show();    // è¾“å‡ºï¼šGeneral type
    TypeTraits<int[5]>::show(); // è¾“å‡ºï¼šArray type
}
```
3. å¤„ç†`std::pair`çš„ç‰¹å®šæƒ…å†µ
```
template <typename T1, typename T2>
class MyPair {
public:
    static void show() { std::cout << "General MyPair\n"; }
};

// ğŸ¯ å½“ T1 å’Œ T2 ç›¸åŒæ—¶ï¼Œä½¿ç”¨æ­¤ç‰¹åŒ–ç‰ˆæœ¬
template <typename T>
class MyPair<T, T> {
public:
    static void show() { std::cout << "Specialized MyPair for same type\n"; }
};

int main() {
    MyPair<int, double>::show(); // è¾“å‡ºï¼šGeneral MyPair
    MyPair<int, int>::show();    // è¾“å‡ºï¼šSpecialized MyPair for same type
}
```
å…¨ç‰¹åŒ–ä¾‹å­ï¼š
```
template <>
class MyClass<int> {  // âœ… å…¨ç‰¹åŒ–ï¼šä»…é€‚ç”¨äº `int`
public:
    static void show() {
        std::cout << "Full specialization for int\n";
    }
};
```

## SFINAEæœºåˆ¶ï¼ˆSubstitution Failure Is Not An Errorï¼‰
SFINAE (Substitution Failure Is Not An Errorï¼Œæ›¿æ¢å¤±è´¥ä¸æ˜¯é”™è¯¯) æ˜¯ C++ æ¨¡æ¿å…ƒç¼–ç¨‹ä¸­çš„ä¸€ä¸ªæ ¸å¿ƒæœºåˆ¶ï¼Œå®ƒå…è®¸ç¼–è¯‘å™¨åœ¨æ¨¡æ¿å‚æ•°æ›¿æ¢å¤±è´¥æ—¶ï¼Œä¸ä¼šæŠ¥ç¼–è¯‘é”™è¯¯ï¼Œè€Œæ˜¯ä¼šå›é€€åˆ°å…¶ä»–å¯ç”¨çš„æ¨¡æ¿ç‰ˆæœ¬ã€‚ä½¿æ¨¡æ¿èƒ½å¤Ÿæ ¹æ®ç±»å‹çš„ç‰¹æ€§è‡ªåŠ¨åŒ¹é…æœ€åˆé€‚çš„ç‰ˆæœ¬ã€‚  
ä½¿ç”¨ä¾‹å­ï¼š  
`std::enable_if`å…è®¸åœ¨æ¨¡æ¿å…ƒç¼–ç¨‹ä¸­æœ‰é€‰æ‹©åœ°ä½¿ç”¨æˆ–ç¦ç”¨æŸäº›æ¨¡æ¿ï¼š
```
#include <iostream>
#include <type_traits>

// ä»…é€‚ç”¨äºæ•´æ•°ç±»å‹
template <typename T, typename = std::enable_if_t<std::is_integral_v<T>>>
void func(T) {
    std::cout << "Integral type\n";
}

// ä»…é€‚ç”¨äºæµ®ç‚¹ç±»å‹
template <typename T, typename = std::enable_if_t<std::is_floating_point_v<T>>>
void func(T) {
    std::cout << "Floating point type\n";
}

int main() {
    func(10);     // âœ… åŒ¹é… `is_integral<T>` -> Integral type
    func(3.14);   // âœ… åŒ¹é… `is_floating_point<T>` -> Floating point type
}
```

åˆæ¯”å¦‚ï¼š
 ```
template <typename iter, 
typename mystl::enable_if<mystl::is_iterator<iter>::value, int>::type = 0,
typename mystl::enable_if<mystl::is_the_same_type<typename mystl::iterator_traits<iter>::value_type, value_type>::value, int>::type = 0>
list(iter first, iter end){
    copy_init(first, end);
}
 ```
å…¶ä¸­`enable_if`çš„å®ç°ä¸ºï¼š
```
template <bool B, typename = void>
struct enable_if {};

template <typename T>
struct enable_if<true, T>{
    using type = T;
};
```
è¿ç”¨äº†éƒ¨åˆ†ç‰¹åŒ–çš„ç‰¹æ€§ï¼Œåªæœ‰å½“B=trueæ—¶å€™ï¼Œç»“æ„ä½“`enable_if`æ‰ä¼šæœ‰`type`è¿™ä¸ªå±æ€§ï¼Œæ‰€ä»¥åœ¨æ¨¡æ¿æ›¿æ¢çš„æ—¶å€™,å¦‚æœ`enable_if`æ¨¡æ¿çš„ç¬¬ä¸€ä¸ªç±»å‹ä¸ä¸º`true`ï¼Œåˆ™`enable_if`ä¸åŒ…å«`type`è¿™ä¸ªå±æ€§ï¼Œä»è€Œå¯¼è‡´`mystl::enable_if<...>::type`çš„æ›¿æ¢å¤±è´¥ï¼Œä»è€Œä½¿ç¼–è¯‘å™¨ä¸é€‰æ‹©è¿™ä¸ªæ¨¡æ¿å‡½æ•°ç¼–è¯‘ã€‚

# å·¦å€¼å’Œå³å€¼
å·¦å€¼ï¼ˆlvalueï¼‰å’Œå³å€¼ï¼ˆrvalueï¼‰æ˜¯å˜é‡å’Œè¡¨è¾¾å¼çš„ä¸€ç§åˆ†ç±»æ–¹å¼ï¼Œä¸»è¦ä¸`å†…å­˜ä½ç½®` (æ˜¯å¦å¯å¯»å€)å’Œ`ç”Ÿå‘½å‘¨æœŸ`ï¼ˆæ˜¯å¦å¯æŒä¹…åŒ–ï¼‰æœ‰å…³  

1. å·¦å€¼
- å®šä¹‰ï¼š å·¦å€¼æ˜¯æŒ‡æœ‰åå­—ï¼Œå¯ä»¥è¢«å¼•ç”¨çš„å¯¹è±¡ï¼Œå®ƒé€šå¸¸è¡¨ç¤ºä¸€ä¸ªå¯ä»¥å–åœ°å€ï¼Œå­˜å‚¨åœ¨å†…å­˜ä¸­çš„å¯¹è±¡  
- ç‰¹ç‚¹ï¼šå·¦å€¼è¡¨ç¤ºå¯ä»¥æŒç»­å­˜åœ¨çš„å†…å­˜ä½ç½®ï¼Œå¯ä»¥åœ¨èµ‹å€¼è¡¨è¾¾å¼çš„å·¦è¾¹ï¼Œä¹Ÿå¯ä»¥åœ¨å³è¾¹ï¼Œå¯ä»¥é€šè¿‡`&`æ“ä½œç¬¦è·å–å®ƒçš„åœ°å€  
eg.  
```
int x = 10;     // x æ˜¯å·¦å€¼
int* p = &x;    // å·¦å€¼å¯ä»¥å–åœ°å€
x = 20;         // å·¦å€¼å¯ä»¥å‡ºç°åœ¨èµ‹å€¼å·å·¦ä¾§
int y = x + 1;  // å·¦å€¼ä¹Ÿå¯ä»¥å‡ºç°åœ¨èµ‹å€¼å·å³ä¾§
```
- å·¦å€¼å¼•ç”¨ï¼šç”¨`&`å£°æ˜ï¼Œå¯ä»¥ç»‘å®šåˆ°å·¦å€¼
  
2. å³å€¼
- å®šä¹‰ï¼šå³å€¼æ˜¯æŒ‡æ²¡æœ‰åå­—ï¼Œåªèƒ½è¢«è¯»çš„ä¸´æ—¶å¯¹è±¡ï¼Œå®ƒé€šå¸¸æ˜¯è¡¨è¾¾å¼çš„ç»“æœï¼Œæ— æ³•é€šè¿‡`&`è·å–åœ°å€
- ç‰¹ç‚¹ï¼šå³å€¼æ˜¯ä¸´æ—¶çš„ï¼Œåœ¨è¯­å¥ç»“æŸåä¼šè¢«é”€æ¯ï¼Œåªèƒ½å‡ºç°åœ¨èµ‹å€¼è¡¨è¾¾å¼çš„å³ä¾§ï¼Œè€Œä¸èƒ½å‡ºç°åœ¨å·¦ä¾§ï¼Œé€šå¸¸æ˜¯å­—é¢å€¼æˆ–è¡¨è¾¾å¼çš„è®¡ç®—ç»“æœ  
eg.
```
int x = 10;       // 10 æ˜¯å³å€¼
int y = x + 1;    // (x + 1) æ˜¯å³å€¼
int* p = &(x + 1); // é”™è¯¯ï¼Œå³å€¼ä¸èƒ½å–åœ°å€
```
- å³å€¼å¼•ç”¨ï¼šç”¨`&&å£°æ˜ï¼Œå¯ä»¥ç»‘å®šåˆ°å³å€¼ï¼Œç”¨äºæ•è·ä¸´æ—¶å¯¹è±¡ï¼Œå»¶é•¿å…¶ç”Ÿå‘½å‘¨æœŸ

3. å·¦å€¼å³å€¼çš„åº•å±‚åŒºåˆ«
- å·¦å€¼å§‹ç»ˆè¡¨ç¤ºå¯ä»¥å‚¨å­˜åœ¨`å†…å­˜`ä¸­çš„å¯¹è±¡  
eg.
```
int x = 10;
int y = x + 1;
```
å¯¹åº”çš„æ±‡ç¼–æŒ‡ä»¤ï¼š
```
mov dword ptr [x], 10       ; å°† 10 å­˜å‚¨åˆ°å˜é‡ x çš„åœ°å€
mov eax, dword ptr [x]      ; å°† x çš„å€¼åŠ è½½åˆ°å¯„å­˜å™¨ eax ä¸­
add eax, 1                  ; å°† eax åŠ  1
mov dword ptr [y], eax      ; å°†ç»“æœå­˜å‚¨åˆ° y çš„åœ°å€
```
- å³å€¼æ²¡æœ‰å›ºå®šçš„å†…å­˜åœ°å€ï¼Œé€šå¸¸åªåœ¨`å¯„å­˜å™¨`æˆ–`æ ˆ`ä¸Šå­˜åœ¨ã€‚  
- è™½ç„¶å³å€¼ä¹Ÿå¯èƒ½å­˜å‚¨åœ¨å†…å­˜çš„æ ˆä¸Šï¼Œä½†ä¸èƒ½è¢«å¯»å€ã€‚  
eg.
```
int y = 10 + 20;
```
å¯¹åº”çš„æ±‡ç¼–æŒ‡ä»¤ï¼š
```
mov eax, 10                 ; å°† 10 åŠ è½½åˆ°å¯„å­˜å™¨ eax
add eax, 20                 ; eax = 10 + 20
mov dword ptr [y], eax      ; å°†ç»“æœå­˜å‚¨åˆ°å˜é‡ y çš„åœ°å€
```
- ç¼–è¯‘å™¨å¯¹å³å€¼çš„ä¼˜åŒ–ï¼š  
**å¯„å­˜å™¨ä¼˜åŒ–**  
å³å€¼æ˜¯è¡¨è¾¾å¼çš„ç»“æœï¼Œé€šå¸¸æ˜¯çŸ­æš‚å­˜åœ¨çš„ä¸´æ—¶å€¼ã€‚ç¼–è¯‘å™¨ä¼šå°½é‡å°†å³å€¼å­˜å‚¨åœ¨å¯„å­˜å™¨ä¸­ï¼Œè€Œä¸æ˜¯å†…å­˜ä¸­ï¼Œä»è€Œå‡å°‘å†…å­˜è®¿é—®ï¼Œæé«˜æ€§èƒ½ã€‚  
**è¿”å›å€¼ä¼˜åŒ–ï¼ˆROVï¼‰**  
è¿”å›å€¼ä¼˜åŒ–ï¼ˆReturn Value Optimization, RVOï¼‰æ˜¯ä¸€ç§ç¼–è¯‘å™¨ä¼˜åŒ–æŠ€æœ¯ï¼Œç”¨äºåœ¨å‡½æ•°è¿”å›å¯¹è±¡æ—¶ï¼Œé¿å…åˆ›å»ºä¸´æ—¶å¯¹è±¡å’Œå¤šä½™çš„æ‹·è´/ç§»åŠ¨æ“ä½œ  
å½“å‡½æ•°è¿”å›å€¼æ˜¯å³å€¼ï¼ˆä¸´æ—¶å¯¹è±¡ï¼‰æ—¶ï¼Œç¼–è¯‘å™¨ä¼šç›´æ¥å°†è¿”å›å€¼æ„é€ åˆ°ç›®æ ‡å¯¹è±¡çš„ä½ç½®ï¼Œè€Œä¸æ˜¯åˆ›å»ºä¸´æ—¶å¯¹è±¡å¹¶å¤åˆ¶åˆ°ç›®æ ‡å¯¹è±¡

# C++11çš„å¯å˜æ¨¡æ¿å‚æ•°ï¼ˆ`typename... Args`ï¼‰

`typename... Args`å®šä¹‰äº†ä¸€ä¸ªæ¨¡æ¿å‚æ•°åŒ…ï¼Œè¡¨ç¤ºå¯ä»¥æ¥å—ä»»æ„æ•°é‡å’Œç±»å‹çš„æ¨¡æ¿å‚æ•°  
`Args&&... args`è¡¨ç¤ºå‡½æ•°å‚æ•°åŒ…ï¼Œè¡¨ç¤ºå¯ä»¥æ¥å—ä¸å®šæ•°é‡å’Œç±»å‹çš„å‚æ•°ï¼Œå¹¶é€šè¿‡å®Œç¾è½¬å‘å°†è¿™äº›å‚æ•°ä¼ é€’ç»™å¦ä¸€ä¸ªå‚æ•°  
å®Œç¾è½¬å‘æ˜¯æŒ‡å°†æ¨¡æ¿å‡½æ•°æ¥æ”¶åˆ°çš„å‚æ•°åŸå°ä¸åŠ¨åœ°è½¬å‘ç»™å¦ä¸€ä¸ªå‡½æ•°ï¼Œä¿ç•™å‚æ•°çš„å€¼ç±»åˆ«
1. è½¬å‘ç»™å…¶å®ƒå‡½æ•°
```cpp
#include <iostream>
#include <string>
#include <utility>

// æ¥æ”¶ä»»æ„æ•°é‡å’Œç±»å‹çš„å‚æ•°
template <typename... Args>
void call_function(Args&&... args) {
    // è½¬å‘å‚æ•°åŒ…åˆ°ç›®æ ‡å‡½æ•°
    target_function(std::forward<Args>(args)...);
}

// ç¤ºä¾‹ç›®æ ‡å‡½æ•°
void target_function(int a, double b, const std::string& c) {
    std::cout << "a: " << a << ", b: " << b << ", c: " << c << std::endl;
}

int main() {
    int x = 42;
    double y = 3.14;
    std::string z = "Hello";

    call_function(x, y, z);  // è½¬å‘å‚æ•°
    return 0;
}
```
å…¶ä¸­`std::forward<T>`æ˜¯ä¸€ä¸ªç”¨äºæ¡ä»¶è½¬å‘çš„å·¥å…·ï¼Œæ ¹æ®æ¨¡æ¿å‚æ•°`T`çš„ç±»å‹ï¼Œåˆ¤æ–­


# ::operator newå’Œ::newå’Œmalloc()

é¦–å…ˆ`::`æ˜¯ä½œç”¨åŸŸè§£æç¬¦ï¼Œä½œç”¨æ˜¯ç¡®ä¿è°ƒç”¨çš„æ˜¯å…¨å±€ä½œç”¨åŸŸä¸‹çš„å‡½æ•°æˆ–è¿ç®—ç¬¦ã€‚åœ¨c++ä¸­newå¯ä»¥è¢«å…¨å±€å®šä¹‰ï¼Œä¹Ÿå¯ä»¥è¢«ç±»é‡è½½ï¼Œå¦‚æœä¸€ä¸ªç±»é‡è½½äº†newï¼Œç›´æ¥è°ƒç”¨newå°±ä¼šè°ƒç”¨è¿™ä¸ªç±»çš„ç‰ˆæœ¬ï¼Œè€Œå¦‚æœåŠ ä¸Š`::`å°±è¡¨æ˜æˆ‘ä»¬è¦è°ƒç”¨å…¨å±€ä½œç”¨åŸŸä¸‹çš„newã€‚  

- `::operator new`: åªåˆ†é…å†…å­˜è€Œä¸è°ƒç”¨æ„é€ å‡½æ•°ã€‚
- `::new`: åˆ†é…å†…å­˜ + è°ƒç”¨æ„é€ å‡½æ•°ã€‚åœ¨åº•å±‚å®ç°ä¸­è°ƒç”¨`::operator new`åˆ†é…å†…å­˜åå†æ„é€ å¯¹è±¡

```cpp
#include <iostream>

class MyClass {
public:
    MyClass() { std::cout << "Constructor Called\n"; }
    ~MyClass() { std::cout << "Destructor Called\n"; }
};

int main() {
    // ä½¿ç”¨ new å…³é”®å­—ï¼ˆä¼šè°ƒç”¨æ„é€ å‡½æ•°ï¼‰
    MyClass* obj1 = new MyClass();  // è¾“å‡º "Constructor Called"
    delete obj1;                    // è¾“å‡º "Destructor Called"

    // ä½¿ç”¨ operator newï¼ˆä»…åˆ†é…å†…å­˜ï¼Œä¸è°ƒç”¨æ„é€ å‡½æ•°ï¼‰
    void* mem = ::operator new(sizeof(MyClass));
    MyClass* obj2 = static_cast<MyClass*>(mem);
    
    // æ‰‹åŠ¨è°ƒç”¨æ„é€ å‡½æ•°
    new (obj2) MyClass();  // è¾“å‡º "Constructor Called"

    // æ‰‹åŠ¨è°ƒç”¨ææ„å‡½æ•°
    obj2->~MyClass();      // è¾“å‡º "Destructor Called"

    // é‡Šæ”¾å†…å­˜
    ::operator delete(mem);
    
    return 0;
}

```

æ³¨ï¼šé€šè¿‡::operator newç”Ÿæˆçš„ç©ºé—´ç»‘å®šå¯¹è±¡åè°ƒç”¨ææ„å‡½æ•°æ—¶ä¸ä¼šé‡Šæ”¾å†…å­˜ï¼Œè¦é¢å¤–è°ƒç”¨`::operator delete()`æ¥é‡Šæ”¾å†…å­˜ã€‚  

| **ç‰¹æ€§**             | **`::operator new`**         | **`::new`ï¼ˆnew è¿ç®—ç¬¦ï¼‰** | **`malloc()`** |
|----------------------|-----------------------------|---------------------------|----------------|
| **ä½œç”¨**            | **ä»…åˆ†é…å†…å­˜**ï¼Œä¸è°ƒç”¨æ„é€ å‡½æ•° | **åˆ†é…å†…å­˜ + è°ƒç”¨æ„é€ å‡½æ•°** | **ä»…åˆ†é…å†…å­˜**ï¼Œä¸è°ƒç”¨æ„é€ å‡½æ•° |
| **è¿”å›ç±»å‹**        | `void*`ï¼Œéœ€è¦è½¬æ¢ä¸ºå¯¹è±¡æŒ‡é’ˆ | `T*`ï¼Œè¿”å›å…·ä½“ç±»å‹æŒ‡é’ˆ | `void*`ï¼Œéœ€è¦è½¬æ¢ä¸ºå¯¹è±¡æŒ‡é’ˆ |
| **æ˜¯å¦è°ƒç”¨æ„é€ å‡½æ•°** | âŒ å¦ | âœ… æ˜¯ | âŒ å¦ |
| **æ˜¯å¦è°ƒç”¨ææ„å‡½æ•°** | âŒ å¦ | âœ… æ˜¯ï¼ˆ`delete` è°ƒç”¨ææ„ï¼‰ | âŒ å¦ |
| **å¤±è´¥æ—¶çš„è¡Œä¸º**    | æŠ›å‡º `std::bad_alloc` | æŠ›å‡º `std::bad_alloc` | è¿”å› `nullptr` |
| **æ˜¯å¦å¯ä»¥é‡è½½**    | âœ… å¯ä»¥ | âŒ ä¸èƒ½é‡è½½ | âŒ ä¸èƒ½é‡è½½ |
| **é€‚ç”¨è¯­è¨€**        | **C++**ï¼ˆè¿ç®—ç¬¦å‡½æ•°ï¼‰ | **C++** | **C/C++** |


1. `::new`
- `new T();`ä¼šè°ƒç”¨ï¼š  
  1. `::operator new(sizeof(T));`åˆ†é…å†…å­˜ã€‚
  2. `T::T();`Tçš„æ„é€ å‡½æ•°ã€‚
- `delete p;`ä¼šè°ƒç”¨
  1. `p->~T();`Tçš„ææ„å‡½æ•°
  2. `::operator delete(p);`é‡Šæ”¾å†…å­˜ã€‚
2. `::operator new`åªè´Ÿè´£å†…å­˜åˆ†é…ï¼Œç±»ä¼¼äº`malloc()`ã€‚  
   ä¸`malloc()`çš„åŒºåˆ«åœ¨äºï¼š`::operator new`ä¼šæŠ›å‡ºå¼‚å¸¸ï¼Œè€Œ`malloc()`è¿”å›`nullptr`ã€‚
3. `malloc()`åªåˆ†é…å†…å­˜ï¼Œä¸çŸ¥é“`T`çš„æ„é€ å‡½æ•°ï¼Œä¸ä¼šåˆå§‹åŒ–å¯¹è±¡ã€‚

# new(`new T()`)å’Œplacement new(`new(ptr) T()`)
1. æ™®é€šçš„new(`new T()`)ä¼šåˆ†é…å†…å­˜å¹¶æ„é€ å¯¹è±¡ï¼š
```
#include <iostream>

class MyClass {
public:
    MyClass(int x) { std::cout << "Constructor: " << x << "\n"; }
    ~MyClass() { std::cout << "Destructor\n"; }
};

int main() {
    MyClass* obj = new MyClass(42);  // âœ… ç”³è¯·æ–°å†…å­˜å¹¶æ„é€ å¯¹è±¡
    delete obj;                      // âœ… è°ƒç”¨ææ„å¹¶é‡Šæ”¾å†…å­˜
    return 0;
}
```
2. è€Œplacement new(`new(ptr) T()`)ä¸ä¼šåˆ†é…æ–°å†…å­˜ï¼Œåªä¼šåœ¨`ptr`æŒ‡å‘çš„å†…å­˜ä¸Šè°ƒç”¨æ„é€ å‡½æ•°ã€‚
```cpp
#include <iostream>

class MyClass {
public:
    MyClass(int x) { std::cout << "Constructor: " << x << "\n"; }
    ~MyClass() { std::cout << "Destructor\n"; }
};

int main() {
    void* mem = ::operator new(sizeof(MyClass));  // âœ… ä»…åˆ†é…å†…å­˜ï¼ˆä¸ä¼šæ„é€ å¯¹è±¡ï¼‰
    MyClass* obj = new (mem) MyClass(42);  // âœ… åœ¨ `mem` æŒ‡å‘çš„å†…å­˜ä¸Šæ„é€ å¯¹è±¡

    obj->~MyClass();  // âœ… æ˜¾å¼è°ƒç”¨ææ„å‡½æ•°
    ::operator delete(mem);  // âœ… é‡Šæ”¾ `operator new` ç”³è¯·çš„å†…å­˜

    return 0;
}
```
# lvalue reference and rvalue reference and universal reference
```cpp
Widget&& var1 = someWidget;      // here, â€œ&&â€ means rvalue referenceï¼Œvar1è™½ç„¶æ˜¯å³å€¼å¼•ç”¨ï¼Œä½†å®ƒä½œä¸ºè¡¨è¾¾å¼çš„æ—¶å€™æ˜¯å·¦å€¼ã€‚
 
auto&& var2 = var1;              // here, â€œ&&â€ does not mean rvalue reference, æ­¤æ—¶var2æ˜¯å·¦å€¼å¼•ç”¨
 
template<typename T>
void f(std::vector<T>&& param);  // here, â€œ&&â€ means rvalue reference
 
template<typename T>
void f(T&& param);               // here, â€œ&&â€does not mean rvalue reference
```
1. å·¦å€¼å¼•ç”¨ï¼ˆlvalue referenceï¼‰  
ç”¨äºç»‘å®šå·¦å€¼å˜é‡ï¼Œå…è®¸é€šè¿‡å¼•ç”¨ä¿®æ”¹å˜é‡çš„å€¼ã€‚
```
int a = 10;
int& ref = a;  // âœ… `ref` ç»‘å®š `a`
ref = 20;      // âœ… ä¿®æ”¹ `a`
```
`const X&`å¯ä»¥ç»‘å®šå·¦å€¼æˆ–å³å€¼  
```
const int& a = 10;  //It's OK.
```
2. å³å€¼å¼•ç”¨ï¼ˆrvalue referenceï¼‰
åªèƒ½ç»‘å®šå³å€¼
```
int&& rref = 10;  // âœ… `rref` ç»‘å®šå³å€¼ 10
```
å³å€¼è¢«å³å€¼å¼•ç”¨ç»‘å®šåä¼šä¸€ç›´å­˜åœ¨ç›´åˆ°å¯¹åº”çš„å³å€¼å¼•ç”¨ç”Ÿå‘½å‘¨æœŸç»“æŸï¼ŒæœŸé—´è¿™ä¸ªå¯¹è±¡å°†ä¼šä¸€ç›´è¢«å­˜å‚¨åœ¨æ ˆä¸Šã€‚  
æ­¤æ—¶è¿™ä¸ªâ€œå³å€¼â€å¯ä»¥è¢«å¯»å€ï¼š  
```
const int& ref = 10;  // âœ… `10` ç»‘å®šåˆ° `ref`ï¼Œç”Ÿå‘½å‘¨æœŸå»¶é•¿
const int* p = &ref;  // âœ… ç°åœ¨ `p` æœ‰åˆæ³•åœ°å€
```

3. ä¸‡èƒ½å¼•ç”¨ï¼ˆuniversal referenceï¼‰  
If a variable or parameter is declared to have type T&& for some deduced type T, that variable or parameter is a universal reference.
```cpp
// åœ¨æ¨¡æ¿å‡½æ•°ä¸­ T&& æˆ–è€…åœ¨å…¶ä»–åœ°æ–¹çš„ auto&&
template <typename T>
void message2(T&& x){
    process(std::forward<T>(x));
}

int main(){
    int a = 10;
    int& var1 = a;          //lvalue reference
    int&& var2 = 11;        //rvalue reference
    auto&& var3 = 12;       //rvalue reference
    auto&& var4 = var2;     //lvalue reference
    return 0;
}
```
åœ¨å‡½æ•°`void message2(T&& x)`ä¸­`T&& x`ä½œä¸ºä¸€ä¸ªä¸‡èƒ½å¼•ç”¨ä½¿ç”¨`std::forward<T>(x)`ä¿ç•™å·¦/å³å€¼å±æ€§ä¼ è¾“å¯¹è±¡ã€‚  
ä½¿ç”¨ä¸‡èƒ½å¼•ç”¨æ—¶ï¼Œè¿™ä¸ªå¼•ç”¨æ—¢å¯ä»¥æ˜¯å·¦å€¼å¼•ç”¨ä¹Ÿå¯ä»¥æ˜¯å³å€¼å¼•ç”¨ï¼Œå–å†³äºå…·ä½“æƒ…å†µã€‚

**æ³¨ï¼š** åªæœ‰å½“å‚æ•°åˆ—è¡¨ä¸­ä½¿ç”¨ä¸‡èƒ½å¼•ç”¨æ—¶ç±»å‹æ¨å¯¼æ‰ä¼šæ˜¯å·¦å€¼æ¨å¯¼ä¸ºT&ï¼Œå³å€¼ä¸ºTã€‚


# `std::forward<T>()` å’Œ `std::move()`

| ç‰¹æ€§ | `std::move()` | `std::forward<T>()` |
|------|-------------|------------------|
| **ä¸»è¦ä½œç”¨** | æ— æ¡ä»¶è½¬æ¢ä¸ºå³å€¼ï¼ˆå…è®¸ç§»åŠ¨è¯­ä¹‰ï¼‰ | ä¿æŒä¼ å…¥å‚æ•°çš„å·¦å€¼/å³å€¼ç‰¹æ€§ï¼ˆå®Œç¾è½¬å‘ï¼‰ |
| **æ˜¯å¦æ”¹å˜å€¼ç±»åˆ«** | å§‹ç»ˆè½¬æ¢ä¸ºå³å€¼ | ä»…åœ¨ `T` æ˜¯å³å€¼æ—¶è½¬æ¢ |
| **é€‚ç”¨äº** | ç§»åŠ¨æ„é€ /ç§»åŠ¨èµ‹å€¼ | æ³›å‹ä»£ç ï¼ˆå‡½æ•°æ¨¡æ¿å‚æ•°ä¼ é€’ï¼‰ |
| **è¿”å›ç±»å‹** | `T&&` | `T&&` |
| **ç”¨æ³•åœºæ™¯** | ç§»åŠ¨å¯¹è±¡èµ„æºï¼Œé¿å…æ˜‚è´µæ‹·è´ | åœ¨æ¨¡æ¿ä¸­ä¿æŒåŸå§‹å‚æ•°çš„å€¼ç±»åˆ« |
| **æ˜¯å¦å½±å“å¯¹è±¡æ‰€æœ‰æƒ** | âœ… æ˜¯ï¼ˆå°†å¯¹è±¡è§†ä¸ºå³å€¼ï¼‰ | âŒ å¦ï¼ˆä»…åœ¨å³å€¼æ—¶æ‰è½¬æ¢ï¼‰ |
| **åº•å±‚å®ç°** | `static_cast<typename std::remove_reference<_Tp>::type&&>(__t)` | `static_cast<T&&>(x);` |

## `std::forward<T>()`
æ ‡å‡†åº“ä¸­ä½¿ç”¨é‡è½½æ¥åˆ†åˆ«å¤„ç†å·¦å€¼å’Œå³å€¼
```cpp
/**
   *  @brief  Forward an lvalue.
   *  @return The parameter cast to the specified type.
   *
   *  This function is used to implement "perfect forwarding".
   */
  template<typename _Tp>
    _GLIBCXX_NODISCARD
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }

  /**
   *  @brief  Forward an rvalue.
   *  @return The parameter cast to the specified type.
   *
   *  This function is used to implement "perfect forwarding".
   */
  template<typename _Tp>
    _GLIBCXX_NODISCARD
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
		    " substituting _Tp must not be an lvalue reference type");
      return static_cast<_Tp&&>(__t);
    }
```
å…¶ä¸­`typename std::remove_reference<_Tp>::type`ç”¨äºå»é™¤ç±»å‹_TPçš„å¼•ç”¨  
ç„¶å`typename std::remove_reference<_Tp>::type&`ä¸ºå·¦å€¼å¼•ç”¨  
`typename std::remove_reference<_Tp>::type&`ä¸ºå³å€¼å¼•ç”¨
ä»¥`int`ç±»å‹ä¸ºä¾‹åˆ†æï¼š
- å¦‚æœ`T = int&`ï¼ˆå·¦å€¼å¼•ç”¨ï¼‰  
  è¿”å›ç±»å‹`T&& = int& &&`,æ ¹æ®å¼•ç”¨æŠ˜å è§„åˆ™ï¼Œä¸º`int &`ï¼ˆå·¦å€¼å¼•ç”¨ï¼‰
- å¦‚æœ`T = int`æˆ–`T = int&&`ï¼ˆå³å€¼å¼•ç”¨ï¼‰
  è¿”å›ç±»å‹`T&& = int&&`æˆ–`T&& = int&& && = int&&`ï¼ˆå³å€¼å¼•ç”¨ï¼‰

`std::forward<T>()`å¸¸ç”¨äºï¼š
1. æ³›å‹å‡½æ•°åŒ…è£…ï¼ˆä¿æŒå·¦å€¼/å³å€¼ç‰¹æ€§ï¼‰  
   å½“ç¼–å†™ä¸€ä¸ª æ³›å‹å‡½æ•°ï¼Œå®ƒæ¥å—ä»»ä½•å‚æ•°å¹¶å°†å…¶ä¼ é€’ç»™å¦ä¸€ä¸ªå‡½æ•°ï¼Œå¦‚æœä¸ä½¿ç”¨ std::forward<T>(arg)ï¼Œå³å€¼ä¼šè¢«é”™è¯¯åœ°è½¬æ¢ä¸ºå·¦å€¼ã€‚
   ä¾‹å¦‚ï¼š
```cpp
#include <iostream>

void process(int& x) { std::cout << "Lvalue reference: " << x << "\n"; }
void process(int&& x) { std::cout << "Rvalue reference: " << x << "\n"; }

template <typename T>
void wrapper(T&& arg) {
    process(std::forward<T>(arg));  // âœ… ä¿æŒ `arg` çš„å·¦å€¼/å³å€¼ç‰¹æ€§
}

int main() {
    int a = 10;
    wrapper(a);   // âœ… ä¼ é€’å·¦å€¼å¼•ç”¨ï¼Œè°ƒç”¨ `process(int&)`
    wrapper(20);  // âœ… ä¼ é€’å³å€¼ï¼Œè°ƒç”¨ `process(int&&)`
}
```
ç¼–è¯‘å™¨ä¼šæ¨å¯¼Tçš„ç±»å‹  
- å¦‚æœä¼ å…¥çš„å€¼æ˜¯å·¦å€¼ï¼ŒTä¼šè¢«æ¨å¯¼ä¸º`int&`, æœ€åå¼•ç”¨æŠ˜å è¿”å›å€¼ä¸ºå·¦å€¼å¼•ç”¨
- å¦‚æœä¼ å…¥çš„æ˜¯å³å€¼ï¼ŒTä¼šè¢«æ¨å¯¼ä¸º`int`ï¼Œæœ€åè¿”å›å³å€¼å¼•ç”¨

2. å˜é•¿å‚æ•°æ¨¡æ¿ï¼ˆå®Œç¾è½¬å‘ï¼‰
åœ¨å˜é•¿å‚æ•°æ¨¡æ¿ä¸­ï¼ˆå¦‚`std::vector::emplace_back()`ï¼‰ï¼Œ`std::forward<T>()`ç¡®ä¿å‚æ•°æŒ‰ç…§åŸå§‹æ–¹å¼ä¼ é€’ï¼Œè€Œä¸ä¼šå¼•å…¥é¢å¤–çš„æ‹·è´ã€‚
```
#include <iostream>
#include <vector>

class Widget {
public:
    Widget(int x, double y) { std::cout << "Widget constructed: " << x << ", " << y << "\n"; }
};

template <typename T, typename... Args>
T* createObject(Args&&... args) {
    return new T(std::forward<Args>(args)...);  // âœ… å®Œç¾è½¬å‘
}

int main() {
    Widget* w = createObject<Widget>(42, 3.14);  // âœ… é¿å…æ‹·è´ï¼Œç›´æ¥æ„é€ 
    delete w;
}
```

## `std::move()`
```
  /**
   *  @brief  Convert a value to an rvalue.
   *  @param  __t  A thing of arbitrary type.
   *  @return The parameter cast to an rvalue-reference to allow moving it.
  */
  template<typename _Tp>
    _GLIBCXX_NODISCARD
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }
```
`move()`çš„å‚æ•°`_TP&& __t`ä¸ºä¸‡èƒ½å¼•ç”¨ï¼Œå·¦å€¼å³å€¼éƒ½å¯ä»¥  
`static_cast<typename std::remove_reference<_Tp>::type&&>`å°†ç±»å‹å»é™¤å¼•ç”¨ä¹‹ååŠ ä¸Š`&&`å˜ä¸ºå³å€¼å¼•ç”¨  
æ•…`move()`ä¸è®ºä»€ä¹ˆå€¼éƒ½ä¼šè¢«è½¬æ¢æˆä¸€ä¸ªå³å€¼å¼•ç”¨

# memcpy
`memcpy`å¤åˆ¶ `n` å­—èŠ‚ çš„æ•°æ®ï¼Œä» æºåœ°å€ `src` å¤åˆ¶åˆ° ç›®æ ‡åœ°å€ `dst`ï¼Œä¸ä¼š å¤„ç†æ•°æ®ç±»å‹æˆ–æ‰§è¡Œæ„é€ /ææ„å‡½æ•°ï¼Œä»…ä»…æ˜¯äºŒè¿›åˆ¶çº§åˆ«çš„æ‹·è´ã€‚
```cpp
void *memcpy(void *dst, const void *src, size_t n);
```
å‚æ•°ï¼š

- `dst`ï¼šç›®æ ‡åœ°å€ï¼ˆå¿…é¡»æœ‰è¶³å¤Ÿçš„å†…å­˜ç©ºé—´ï¼‰ã€‚
- `src`ï¼šæºåœ°å€ã€‚
- `n`ï¼šéœ€è¦å¤åˆ¶çš„å­—èŠ‚æ•°ã€‚  
  
è¿”å›å€¼ï¼š
- `memcpy` è¿”å› `dst` çš„æŒ‡é’ˆï¼Œä»¥ä¾¿æ”¯æŒé“¾å¼è°ƒç”¨ã€‚


# is_trivially_copyable

## 1. ä»€ä¹ˆæ˜¯ `is_trivially_copyable`ï¼Ÿ

**C++ æ ‡å‡†ï¼ˆ[basic.types] 6.8.2ï¼‰è§„å®š**ï¼š
> **ä¸€ä¸ªç±»å‹æ˜¯ `is_trivially_copyable`ï¼Œå½“ä¸”ä»…å½“å®ƒçš„æ‹·è´/ç§»åŠ¨æ„é€ å’Œæ‹·è´/ç§»åŠ¨èµ‹å€¼è¿ç®—ç¬¦æ˜¯å¹³å‡¡çš„ï¼Œå¹¶ä¸”å®ƒçš„ææ„å‡½æ•°æ˜¯å¹³å‡¡çš„ã€‚**

âœ… è¿™æ„å‘³ç€ï¼š
- **å¯ä»¥å®‰å…¨åœ°æŒ‰äºŒè¿›åˆ¶æ–¹å¼å¤åˆ¶ï¼ˆ`memcpy`ï¼‰**
- **ä¸ä¾èµ–æ„é€ å‡½æ•°æˆ–ææ„å‡½æ•°è¿›è¡Œç‰¹æ®Šåˆå§‹åŒ–æˆ–æ¸…ç†**
- **å¯ä»¥å­˜å‚¨åœ¨ `union` é‡Œ**
- **å¯ä»¥é€šè¿‡ `memcpy` æ‹·è´è€Œä¸å½±å“ç¨‹åºé€»è¾‘**

ç¤ºä¾‹ï¼š
```cpp
#include <iostream>
#include <type_traits>

struct Trivial {
    int x, y;
}; // Trivially Copyable âœ…

struct NonTrivial {
    std::string s;  // éå¹³å‡¡æˆå‘˜
}; // Not Trivially Copyable âŒ

int main() {
    std::cout << std::boolalpha;
    std::cout << "Trivial: " << std::is_trivially_copyable<Trivial>::value << '\n'; // true
    std::cout << "NonTrivial: " << std::is_trivially_copyable<NonTrivial>::value << '\n'; // false
}
```
## 2. ä¸ºä»€ä¹ˆ`memcpy`åªèƒ½ç”¨äº`is_trivially_copyable`?
**(1)`memcpy`æ˜¯è£¸æ‹·è´**  
`memcpy`æŒ‰å­—èŠ‚å¤åˆ¶æ•°æ®ï¼Œä¸æ‰§è¡Œä»»ä½•æ„é€ ï¼Œææ„æˆ–åˆå§‹åŒ–æ“ä½œã€‚ä¾‹å¦‚ï¼š
```
Trivial a = {1, 2};
Trivial b;
std::memcpy(&b, &a, sizeof(Trivial));  // âœ… åˆæ³•
std::cout << b.x << ", " << b.y << std::endl; // 1, 2
```
**(2)**
`memcpy` ä¸èƒ½ç”¨äºé `Trivially Copyable` ç±»å‹  
ä¾‹å¦‚ï¼š
å¦‚æœ `memcpy` å¤åˆ¶ `std::string`ï¼Œä¼šå¯¼è‡´æœªå®šä¹‰è¡Œä¸ºï¼ˆUBï¼‰ï¼š
```cpp
#include <iostream>
#include <cstring>
#include <string>

struct NonTrivial {
    std::string s;
};

int main() {
    NonTrivial a{"hello"};
    NonTrivial b;
    std::memcpy(&b, &a, sizeof(NonTrivial));  // âŒ UB

    std::cout << b.s << std::endl; // â“ æœªå®šä¹‰è¡Œä¸º
}
```
- `std::string`ç®¡ç†ä¸€ä¸ªåŠ¨æ€`char*`(å †å†…å­˜)
- `memcpy`åªæ˜¯å¤åˆ¶æŒ‡é’ˆåœ°å€ï¼Œä¸ä¼šå¤åˆ¶å †å†…å­˜ã€‚
- ç»“æœå¯¼è‡´:  
b.s ä»ç„¶æŒ‡å‘ a.s çš„æ•°æ®ï¼Œä½† b.s è®¤ä¸ºè‡ªå·±æ‹¥æœ‰è¿™å—å†…å­˜ï¼ˆæµ…æ‹·è´ï¼‰ã€‚  
å½“ b.s ææ„æ—¶ï¼Œå®ƒä¼šé‡Šæ”¾ a.s çš„æ•°æ®ï¼Œå¯¼è‡´ a.s å˜æˆæ‚¬ç©ºæŒ‡é’ˆã€‚  
æœ€ç»ˆå¯¼è‡´åŒé‡é‡Šæ”¾ï¼ˆdouble freeï¼‰ï¼Œç¨‹åºå´©æºƒ

**(3)`memcpy`å’Œ`std::copy`**
- `memcpy`ç›´æ¥å¤åˆ¶äºŒè¿›åˆ¶æ•°æ®ã€‚
- `std::copy`ä¼šè°ƒç”¨æ‹·è´æ„é€ å‡½æ•°ã€‚



# çº¢é»‘æ ‘
https://blog.csdn.net/cy973071263/article/details/122543826

# C++å¤šçº¿ç¨‹ç¼–ç¨‹

## C++ å†…å­˜åºï¼ˆMemory Orderï¼‰æ¦‚è¿°

åœ¨ C++11 åŠå…¶ä¹‹åçš„æ ‡å‡†ä¸­ï¼Œä¸ºäº†æ›´å¥½åœ°æ”¯æŒå¹¶å‘ç¼–ç¨‹ï¼ŒC++ æä¾›äº†åŸå­æ“ä½œï¼ˆ`std::atomic`ï¼‰ä»¥åŠä¸€å¥—å†…å­˜æ¨¡å‹ï¼ˆMemory Modelï¼‰ã€‚å†…å­˜æ¨¡å‹é€šè¿‡å†…å­˜åºï¼ˆMemory Orderï¼‰æ¥è§„å®šä¸åŒåŸå­æ“ä½œä¹‹é—´åœ¨å†…å­˜è®¿å­˜é¡ºåºä¸Šçš„çº¦æŸï¼Œä»¥ç¡®ä¿å¤šçº¿ç¨‹ç¯å¢ƒä¸­çš„æ­£ç¡®æ€§å’Œæ€§èƒ½ä¹‹é—´çš„å¹³è¡¡ã€‚

### ä¸ºä»€ä¹ˆéœ€è¦å†…å­˜åºï¼Ÿ
åœ¨å¤šçº¿ç¨‹ç¯å¢ƒä¸‹ï¼Œç¼–è¯‘å™¨å’Œå¤„ç†å™¨ä¼šå¯¹æŒ‡ä»¤è¿›è¡Œå„ç§ä¼˜åŒ–å’Œé‡æ’ã€‚å¦‚æœæ²¡æœ‰æ˜¾å¼çš„åŒæ­¥æˆ–åºåˆ—ä¿è¯ï¼Œçº¿ç¨‹é—´å¯¹äºå…±äº«æ•°æ®çš„æ›´æ–°å’Œè¯»å–å¯èƒ½å‡ºç°ä¸å¯é¢„æœŸçš„è¡Œä¸ºã€‚é€šè¿‡æŒ‡å®šå†…å­˜åºï¼Œå¼€å‘è€…å¯ä»¥å‘Šè¯‰ç¼–è¯‘å™¨å’Œç¡¬ä»¶ï¼šåœ¨å“ªäº›æƒ…å†µä¸‹éœ€è¦ç¦æ­¢é‡æ’ã€åœ¨å“ªäº›æƒ…å†µä¸‹å¯ä»¥æ”¾æ¾é‡æ’ï¼Œä»è€Œåœ¨ä¿è¯æ­£ç¡®æ€§çš„åŒæ—¶è·å–æ›´é«˜çš„æ‰§è¡Œæ•ˆç‡ã€‚

### å¸¸è§çš„å‡ ç§å†…å­˜åº

C++ æ ‡å‡†å®šä¹‰äº†å…­ç§å†…å­˜åºï¼ˆ`std::memory_order`ï¼‰æšä¸¾å€¼ï¼Œæ¯ç§çš„å¼ºçº¦æŸç¨‹åº¦å„ä¸ç›¸åŒã€‚

1. **`memory_order_relaxed`**
   - æœ€å¼±çš„å†…å­˜åºï¼Œä¸æä¾›ä»»ä½•åŒæ­¥æˆ–è€…é¡ºåºä¿è¯ã€‚
   - ä»…ä¿è¯å¯¹è¯¥åŸå­æ“ä½œçš„åŸå­æ€§ï¼ˆä¸å¯åˆ†å‰²ï¼‰ï¼Œä½†å¯¹å…¶ä»–è¯»å†™æ“ä½œçš„å¯è§æ€§å’Œé¡ºåºä¸ä½œä¿è¯ã€‚
   - é€‚ç”¨äºè®¡æ•°å™¨ã€ç»Ÿè®¡é‡ç­‰æŸäº›å¯¹é¡ºåºæ— ä¸¥æ ¼éœ€æ±‚çš„åœºæ™¯ã€‚
   - ç¤ºä¾‹ï¼ˆçº¿ç¨‹å®‰å…¨è®¡æ•°ï¼Œä½†æ— åºä¿è¯ï¼‰ï¼š
     ```cpp
     #include <atomic>
     #include <iostream>

     std::atomic<int> counter{0};

     void threadFunc() {
         for (int i = 0; i < 10000; i++) {
             // ä»…ä¿è¯å¯¹ counter++ çš„åŸå­æ€§ï¼Œæ— å…¶ä»–é¡ºåºä¿éšœ
             counter.fetch_add(1, std::memory_order_relaxed);
         }
     }
     ```

2. **`memory_order_consume`**ï¼ˆå·²è¢«å¤§éƒ¨åˆ†ç¼–è¯‘å™¨åºŸå¼ƒæˆ–è§†ä¸º `memory_order_acquire` å¤„ç†ï¼‰
   - æœ€åˆçš„å®šä¹‰æ˜¯ï¼šä¿è¯å¯¹ä¾èµ–äºæœ¬æ¬¡åŠ è½½ç»“æœçš„æ“ä½œå¯è§æ€§ï¼Œä½†ç¼–è¯‘å™¨åœ¨å®ç°ä¸­æ™®éæœ‰äº‰è®®ï¼Œç›®å‰å®é™…æ„ä¹‰ä¸å¤§ã€‚
   - å› æ­¤ï¼Œå¤§å¤šæ•°æƒ…å†µä¸‹å¯ä»¥å¿½ç•¥æˆ–è§†ä¸º `memory_order_acquire`ã€‚

3. **`memory_order_acquire`**
   - åœ¨ä»åŸå­å¯¹è±¡è¿›è¡Œâ€œè¯»å–/åŠ è½½â€æ—¶ä½¿ç”¨ï¼Œå¯é˜²æ­¢æœ¬çº¿ç¨‹ä¸­åç»­çš„æ‰€æœ‰è¯»å†™æ“ä½œé‡æ’åˆ°è¯¥åŠ è½½ä¹‹å‰ã€‚
   - å³ï¼Œâ€œè·å–â€è¯­ä¹‰ï¼šåœ¨å½“å‰çº¿ç¨‹ä¸­ï¼Œåé¢çš„æ“ä½œä¸å¾—è·‘åˆ°è¿™ä¸ªåŠ è½½ä¹‹å‰ã€‚
   - å…¶ä¸ `memory_order_release` é…åˆï¼Œå¯å®ç°ç±»ä¼¼â€œäº’æ–¥é”â€èˆ¬çš„åŒæ­¥ã€‚
   - ç¤ºä¾‹ï¼š
     ```cpp
     #include <atomic>

     std::atomic<bool> flag{false};
     int sharedData = 0;

     void producer() {
         sharedData = 42; // å‡†å¤‡æ•°æ®
         flag.store(true, std::memory_order_release); // å‘å¸ƒæ•°æ®
     }

     void consumer() {
         while (!flag.load(std::memory_order_acquire)) {
             // ç­‰å¾… flag å˜ä¸º true
         }
         // è¿™é‡Œè¯»å– sharedData ä¸€å®šçœ‹åˆ°æœ€æ–°å€¼ 42
     }
     ```

4. **`memory_order_release`**
   - åœ¨å¯¹åŸå­å¯¹è±¡è¿›è¡Œâ€œå†™å…¥/å­˜å‚¨â€æ—¶ä½¿ç”¨ï¼Œå¯é˜²æ­¢å½“å‰çº¿ç¨‹ä¸­ä¹‹å‰çš„æ‰€æœ‰è¯»å†™æ“ä½œè¢«é‡æ’åˆ°å­˜å‚¨æ“ä½œä¹‹åã€‚
   - å³ï¼Œâ€œé‡Šæ”¾â€è¯­ä¹‰ï¼šåœ¨å½“å‰çº¿ç¨‹ä¸­ï¼Œä¹‹å‰çš„æ“ä½œä¸å¾—è·‘åˆ°è¿™ä¸ªå­˜å‚¨ä¹‹åã€‚
   - ä¸ `memory_order_acquire` é…åˆï¼Œå°±å¯ä»¥åœ¨çº¿ç¨‹ä¹‹é—´ä¼ é€’æ•°æ®çš„å¯è§æ€§ã€‚

5. **`memory_order_acq_rel`**
   - åŒæ—¶å…·æœ‰ `memory_order_acquire` å’Œ `memory_order_release` çš„è¯­ä¹‰ã€‚
   - é€‚ç”¨äºåŸå­æ“ä½œæ—¢æ˜¯è¯»åˆæ˜¯å†™çš„åœºæ™¯ï¼ˆå¦‚ `fetch_add`ã€`compare_exchange` ç­‰ï¼‰ã€‚
   - åœ¨è¿™æ ·çš„å¤åˆæ“ä½œä¸­ï¼Œæ—¢éœ€è¦åœ¨è¯»å–é˜¶æ®µé˜²æ­¢åç»­é‡æ’ï¼Œä¹Ÿéœ€è¦åœ¨å†™å…¥é˜¶æ®µé˜²æ­¢ä¹‹å‰é‡æ’ã€‚

6. **`memory_order_seq_cst`ï¼ˆSequential Consistencyï¼‰**
   - æœ€ä¸¥æ ¼çš„ä¸€ç§å†…å­˜åºï¼Œæ‰€æœ‰ä½¿ç”¨ `memory_order_seq_cst` çš„åŸå­æ“ä½œï¼Œä¼šå¦‚åŒ**å…¨å±€é¡ºåºä¸€è‡´**åœ°æ‰§è¡Œã€‚
   - å¯¹æ‰€æœ‰ä½¿ç”¨æ­¤å†…å­˜åºçš„æ“ä½œæ¥è¯´ï¼Œç¨‹åºè¡¨ç°å¾—å°±åƒæ‰€æœ‰çš„è¿™äº›åŸå­æ“ä½œéƒ½æŒ‰ç…§å…¨å±€ç»Ÿä¸€é¡ºåºè¢«ä¾æ¬¡æ‰§è¡Œä¸€æ ·ã€‚
   - ç¼–è¯‘å™¨å’Œå¤„ç†å™¨éƒ½å¿…é¡»ä¿è¯è¿™äº›æ“ä½œä¸ä¼šè¢«ä¹±åºåˆ°å…¶ä»– `seq_cst` æ“ä½œä¹‹å‰æˆ–ä¹‹åã€‚
   - åœ¨ä¿è¯ç¨‹åºæ­£ç¡®æ€§æ–¹é¢æœ€ç®€å•ç›´æ¥ï¼Œä½†é€šå¸¸æ€§èƒ½æˆæœ¬æœ€é«˜ã€‚
   - ç¤ºä¾‹ï¼ˆå…¨å±€é¡ºåºä¸€è‡´æ€§ï¼‰ï¼š
     ```cpp
     #include <atomic>
     #include <iostream>
     #include <thread>

     std::atomic<int> a{0};
     std::atomic<int> b{0};

     void thread1() {
         a.store(1, std::memory_order_seq_cst);
         std::cout << "thread1 sees b = " << b.load(std::memory_order_seq_cst) << std::endl;
     }

     void thread2() {
         b.store(1, std::memory_order_seq_cst);
         std::cout << "thread2 sees a = " << a.load(std::memory_order_seq_cst) << std::endl;
     }

     int main() {
         std::thread t1(thread1);
         std::thread t2(thread2);
         t1.join();
         t2.join();
         return 0;
     }
     ```
   - ç†è®ºä¸Šï¼Œè¿™ä¸ªç¨‹åº**ä¸ä¼š**å‡ºç° `thread1 sees b = 0` ä¸ `thread2 sees a = 0` åŒæ—¶å‘ç”Ÿçš„æƒ…å†µï¼ˆåœ¨ `seq_cst` è¯­ä¹‰ä¸‹ï¼‰ã€‚

### å¦‚ä½•é€‰æ‹©åˆé€‚çš„å†…å­˜åºï¼Ÿ
- **`memory_order_relaxed`**ï¼šè‹¥ä»…éœ€è¦åŸå­æ€§ï¼Œä¸å…³å¿ƒé¡ºåºä¿è¯ï¼Œä¾‹å¦‚å¯¹è®¡æ•°å™¨çš„ç»Ÿè®¡æˆ–éå…³é”®æ€§æ•°æ®çš„åˆ·æ–°ï¼Œé€‰ç”¨å®ƒå¯ä»¥è·å¾—æœ€ä½³æ€§èƒ½ã€‚
- **`memory_order_release` / `memory_order_acquire`**ï¼šå¸¸ç”¨äºå®ç°å…¸å‹çš„ç”Ÿäº§è€…-æ¶ˆè´¹è€…ã€å•å‘æ•°æ®ä¾èµ–åœºæ™¯ï¼›å†™çº¿ç¨‹é‡Šæ”¾æ•°æ®ï¼Œè¯»çº¿ç¨‹è·å–æ•°æ®ã€‚
- **`memory_order_acq_rel`**ï¼šæ—¢éœ€è¦è·å–åˆéœ€è¦é‡Šæ”¾çš„å¤åˆè¯»æ”¹å†™æ“ä½œï¼ˆå¦‚ `fetch_add`ã€`compare_exchange_strong` ç­‰ï¼‰ã€‚
- **`memory_order_seq_cst`**ï¼šåœ¨éœ€è¦å…¨å±€é¡ºåºä¸€è‡´æ€§ã€æœ€ç®€å•æ˜“ç†è§£çš„æƒ…å½¢ä¸‹ï¼Œæˆ–è€…æ— æ³•ç¡®å®šå…¶ä»–æ›´æ¾çš„åºæ—¶ï¼Œå¯ä»¥ä½œä¸ºå®‰å…¨é»˜è®¤å€¼ï¼Œä½†å¾€å¾€æ€§èƒ½ç›¸å¯¹è¾ƒå·®ã€‚

### æ€»ç»“
C++ æä¾›çš„å†…å­˜åºæœºåˆ¶å…è®¸æˆ‘ä»¬åœ¨ä¿è¯å¹¶å‘æ­£ç¡®æ€§çš„åŒæ—¶ï¼Œé€šè¿‡é€‰æ‹©ä¸åŒç¨‹åº¦çš„é¡ºåºçº¦æŸæ¥è·å¾—æ›´é«˜çš„æ€§èƒ½ã€‚åˆç†åœ°é€‰æ‹©å†…å­˜åºï¼Œéœ€è¦ç»“åˆåº”ç”¨åœºæ™¯å¯¹äºæ•°æ®ä¸€è‡´æ€§ã€å¯è§æ€§ã€å¹¶å‘å†²çªåŠå¯ç»´æŠ¤æ€§ç­‰å¤šæ–¹é¢å› ç´ è¿›è¡Œæƒè¡¡ã€‚å¦‚æœå¯¹å¹¶å‘ç¼–ç¨‹å’Œå†…å­˜æ¨¡å‹æ¯”è¾ƒé™Œç”Ÿï¼Œä½¿ç”¨é»˜è®¤çš„ `memory_order_seq_cst` åˆ™èƒ½å¤Ÿä¿è¯æœ€ç®€å•ç›´è§‚çš„è¯­ä¹‰ï¼›è€Œåœ¨é«˜æ€§èƒ½åœºæ™¯ä¸‹ï¼Œå¯èƒ½éœ€è¦ç†Ÿç»ƒåº”ç”¨ `release/acquire` æˆ–æ›´å¼±çš„å†…å­˜åºä»¥å……åˆ†æŒ–æ˜æ½œèƒ½ã€‚


## `std::mutex`
äº’æ–¥é‡ï¼ˆMutexï¼‰å¯ä»¥å°†ä¸€æ®µä»£ç ä¿æŠ¤èµ·æ¥ï¼Œä½¿å¾—åœ¨ä»»æ„æ—¶åˆ»åªæœ‰ä¸€ä¸ªçº¿ç¨‹å¯ä»¥æ‰§è¡Œè¿™æ®µè¢«ä¿æŠ¤çš„ä»£ç ï¼ˆæˆ–è®¿é—®è¢«ä¿æŠ¤çš„æ•°æ®ï¼‰ï¼Œä»¥æ­¤æ¥é˜²æ­¢æ•°æ®ç«äº‰ï¼ˆData Raceï¼‰ã€‚

### åŸºæœ¬ä½¿ç”¨
C++11 æ ‡å‡†åº“åœ¨å¤´æ–‡ä»¶ `<mutex>` ä¸­æä¾›äº† `std::mutex`ã€‚ä½¿ç”¨äº’æ–¥é‡çš„å…¸å‹æ­¥éª¤ä¸ºï¼š
1. åˆ›å»ºä¸€ä¸ª `std::mutex` å¯¹è±¡ï¼ˆé€šå¸¸ä½œä¸ºå…±äº«å¯¹è±¡ï¼‰ã€‚
2. åœ¨éœ€è¦ä¿æŠ¤çš„ä¸´ç•ŒåŒºï¼ˆä¸´ç•Œèµ„æºï¼‰å‰ï¼Œå¯¹äº’æ–¥é‡è¿›è¡Œä¸Šé”ï¼ˆlockï¼‰ã€‚
3. æ‰§è¡Œå®Œä¸´ç•ŒåŒºæ“ä½œåï¼Œå¯¹äº’æ–¥é‡è§£é”ï¼ˆunlockï¼‰ã€‚

æ‰‹åŠ¨åŠ é”è§£é”:
```cpp
#include <mutex>
#include <thread>
#include <iostream>

std::mutex mtx;          // äº’æ–¥é‡å¯¹è±¡
int sharedCounter = 0;   // å…±äº«æ•°æ®

void increment() {
    for (int i = 0; i < 10000; ++i) {
        mtx.lock();      // åŠ é”
        ++sharedCounter; // ä¸´ç•ŒåŒº
        mtx.unlock();    // è§£é”
    }
}

int main() {
    std::thread t1(increment);
    std::thread t2(increment);
    t1.join();
    t2.join();
    std::cout << "Result: " << sharedCounter << std::endl;
    return 0;
}
```

### ä½¿ç”¨RAIIæ–¹å¼åŠ é”è§£é”
ä¸ºäº†é¿å…æ‰‹åŠ¨ `lock/unlock` å¸¦æ¥çš„é£é™©ï¼Œé€šå¸¸æ¨èä½¿ç”¨ `std::lock_guard` æˆ– `std::unique_lock` è¿™ç±» RAIIï¼ˆResource Acquisition Is Initializationï¼‰ç±»å‹ã€‚

- `std::lock_guard` åœ¨æ„é€ å‡½æ•°ä¸­è·å–é”ï¼Œåœ¨ææ„å‡½æ•°ä¸­é‡Šæ”¾é”ï¼ŒæœŸé—´ä¸æ”¯æŒæ‰‹åŠ¨è§£é”ã€‚
- `std::unique_lock` ä¹Ÿåœ¨æ„é€ æ—¶ä¸Šé”ã€ææ„æ—¶è§£é”ï¼Œä½†è¿˜å…è®¸æ‰‹åŠ¨é”/è§£é”ã€‚
```cpp
#include <mutex>
#include <thread>
#include <iostream>

std::mutex mtx;
int sharedCounter = 0;

void increment() {
    for (int i = 0; i < 10000; ++i) {
        // RAII æ–¹å¼åŠ é”ï¼Œä¼šåœ¨ä½œç”¨åŸŸç»“æŸæ—¶è‡ªåŠ¨è§£é”
        std::lock_guard<std::mutex> lk(mtx);
        ++sharedCounter;
    }
}

int main() {
    std::thread t1(increment);
    std::thread t2(increment);
    t1.join();
    t2.join();
    std::cout << "Result: " << sharedCounter << std::endl;
    return 0;
}
```

## `std::condtion_variable`
äº’æ–¥é‡èƒ½ç¡®ä¿ä¸´ç•ŒåŒºçš„äº’æ–¥è®¿é—®ï¼Œä½†æœ‰äº›åœºæ™¯å¸Œæœ›è®©çº¿ç¨‹åœ¨ç­‰å¾…æŸäº›æ¡ä»¶æ»¡è¶³æ—¶è¿›å…¥é˜»å¡çŠ¶æ€ï¼Œé¿å…å¿™ç­‰ï¼ˆbusy waitingï¼‰ã€‚ä¸€ä¸ªå…¸å‹ä¾‹å­æ˜¯ç”Ÿäº§è€…-æ¶ˆè´¹è€…æ¨¡å¼ï¼Œæ¶ˆè´¹è€…çº¿ç¨‹éœ€è¦ç­‰å¾…â€œé˜Ÿåˆ—ä¸­æœ‰æ•°æ®å¯æ¶ˆè´¹â€è¿™ä¸€æ¡ä»¶æ»¡è¶³ï¼Œè€Œç”Ÿäº§è€…çº¿ç¨‹è´Ÿè´£å¾€é˜Ÿåˆ—ä¸­æ”¾æ•°æ®ã€‚

å¦‚æœåªç”¨äº’æ–¥é‡åŠ å¾ªç¯æ¥å®ç°ï¼Œæ¶ˆè´¹è€…å¯èƒ½éœ€è¦ä¸æ–­è½®è¯¢é˜Ÿåˆ—æ˜¯å¦ä¸ºç©ºï¼Œä¼šæµªè´¹ CPU æ—¶é—´ã€‚ä¸ºæ­¤ï¼ŒC++ æä¾›äº† `std::condition_variable` æ¥è¿›è¡Œé«˜æ•ˆçš„äº‹ä»¶é€šçŸ¥å’Œç­‰å¾…æœºåˆ¶ã€‚

### åŸºæœ¬åŸç†
- çº¿ç¨‹ Aï¼ˆç­‰å¾…æ–¹ï¼‰è°ƒç”¨ `cv.wait(lk, predicate)` æ—¶ï¼Œå¦‚æœ `predicate` æ¡ä»¶ä¸æ»¡è¶³ï¼Œçº¿ç¨‹ A å°±ä¼šè¿›å…¥é˜»å¡çŠ¶æ€ï¼Œå¹¶ä¸”è‡ªåŠ¨é‡Šæ”¾ä¸å…¶ç»‘å®šçš„äº’æ–¥é‡ `lk`ï¼ˆè¿™æ˜¯ condition_variable åšçš„å…³é”®äº‹æƒ…ï¼‰ã€‚
- å½“çº¿ç¨‹ Bï¼ˆé€šçŸ¥æ–¹ï¼‰å®Œæˆäº†æ”¹å˜æ•°æ®çŠ¶æ€åï¼Œè°ƒç”¨ `cv.notify_one()` æˆ– `cv.notify_all()` æ¥å”¤é†’ä¸€ä¸ªæˆ–å¤šä¸ªç­‰å¾…çº¿ç¨‹ã€‚è¢«å”¤é†’åï¼Œçº¿ç¨‹ A ä¼šé‡æ–°è·å– `lk`ï¼Œå¹¶å†æ¬¡æ£€æŸ¥ `predicate`ï¼Œè‹¥æ¡ä»¶æ»¡è¶³åˆ™ç»§ç»­æ‰§è¡Œï¼Œå¦åˆ™åˆå›åˆ°ç­‰å¾…çŠ¶æ€ã€‚  

### æ ¸å¿ƒå‡½æ•°

- `wait(std::unique_lock<std::mutex>& lk)`
ç­‰å¾…é€šçŸ¥ï¼Œè¿›å…¥é˜»å¡çŠ¶æ€å‰ä¼šå…ˆè§£é” lkã€‚è¢«å”¤é†’åï¼Œå‡½æ•°ä¼šé‡æ–°è·å– lk å¹¶è¿”å›ï¼Œä½†ä¸æ£€æŸ¥ä»»ä½•æ¡ä»¶ã€‚éœ€è‡ªè¡Œåœ¨å¤–å±‚ç”¨å¾ªç¯åˆ¤æ–­æ¡ä»¶æ˜¯å¦æ»¡è¶³ã€‚
- `wait(std::unique_lock<std::mutex>& lk, Predicate pred)`
å¸¦è°“è¯ç‰ˆæœ¬ï¼Œå†…éƒ¨ä¼šå¾ªç¯æ£€æŸ¥ pred æ˜¯å¦ä¸º trueï¼Œåªæœ‰æ»¡è¶³æ‰é€€å‡º waitï¼›å¦åˆ™ç»§ç»­ç­‰å¾…ã€‚å¯ä»¥é¿å…é¢å¤–çš„æ‰‹åŠ¨å¾ªç¯ã€‚
- `notify_one()`
å”¤é†’ä¸€ä¸ªæ­£åœ¨ç­‰å¾…çš„çº¿ç¨‹ã€‚è‹¥æ— çº¿ç¨‹ç­‰å¾…ï¼Œåˆ™è¯¥è°ƒç”¨æ— æ•ˆæœã€‚
- `notify_all()`
å”¤é†’æ‰€æœ‰æ­£åœ¨ç­‰å¾…çš„çº¿ç¨‹ã€‚

### å…¸å‹æ¡ˆä¾‹ï¼šç”Ÿäº§è€…-æ¶ˆè´¹è€…
```cpp
#include <iostream>
#include <mutex>
#include <condition_variable>
#include <thread>
#include <queue>
#include <chrono>

std::mutex mtx;
std::condition_variable cv;
std::queue<int> goods;         // å…±äº«é˜Ÿåˆ—
bool finished = false;         // æ ‡è¯†ç”Ÿäº§ç»“æŸ

// æ¶ˆè´¹è€…çº¿ç¨‹
void consumer(int id) {
    while (true) {
        std::unique_lock<std::mutex> lk(mtx);
        // ç­‰å¾…æ¡ä»¶ï¼šå½“é˜Ÿåˆ—ä¸ºç©ºä¸”æœªç»“æŸç”Ÿäº§æ—¶ï¼Œé˜»å¡ç­‰å¾…
        cv.wait(lk, [] { return !goods.empty() || finished; });

        if (!goods.empty()) {
            int item = goods.front();
            goods.pop();
            lk.unlock();  // è§£é”è®©å…¶ä»–çº¿ç¨‹å¹¶å‘åœ°æ‹¿æ•°æ®
            std::cout << "[Consumer " << id << "] consumed item: " << item << "\n";
        } else if (finished) {
            // ç”Ÿäº§å·²ç»ç»“æŸï¼Œä¸”æ­¤æ—¶é˜Ÿåˆ—ä¸ºç©º
            std::cout << "[Consumer " << id << "] finished.\n";
            break;
        }
    }
}

// ç”Ÿäº§è€…çº¿ç¨‹
void producer(int itemCount) {
    for (int i = 1; i <= itemCount; ++i) {
        {
            std::lock_guard<std::mutex> lk(mtx);
            goods.push(i);
            std::cout << "[Producer] produced item: " << i << "\n";
        }
        cv.notify_one();  // é€šçŸ¥ä¸€ä¸ªç­‰å¾…çš„æ¶ˆè´¹è€…
        std::this_thread::sleep_for(std::chrono::milliseconds(50));
    }
    {
        std::lock_guard<std::mutex> lk(mtx);
        finished = true;
    }
    cv.notify_all();  // é€šçŸ¥æ‰€æœ‰æ¶ˆè´¹è€…ç”Ÿäº§ç»“æŸ
}

int main() {
    std::thread c1(consumer, 1);
    std::thread c2(consumer, 2);
    std::thread p1(producer, 10);

    c1.join();
    c2.join();
    p1.join();

    return 0;
}
```

## `std::future`

`std::future` æ˜¯ C++11 å¼•å…¥çš„ä¸€ä¸ªå¼‚æ­¥ç»“æœè·å–æœºåˆ¶ã€‚å®ƒåŒ…è£…äº†ä¸€ä¸ªå¯èƒ½ä¼šåœ¨å°†æ¥æŸä¸ªæ—¶åˆ»æ‰å®Œæˆè®¡ç®—çš„ç»“æœï¼Œä½ å¯ä»¥é€šè¿‡ `future` åœ¨åç»­çš„ä»£ç é‡Œç­‰å¾…æˆ–è·å–è¿™ä¸ªç»“æœã€‚

å½“åœ¨ä»£ç ä¸­å¼€å¯ä¸€ä¸ªå¼‚æ­¥æ“ä½œæ¯”å¦‚ä½¿ç”¨ `std::async`ã€`std::packaged_task` æˆ–çº¿ç¨‹æ± æäº¤ä¸€ä¸ªä»»åŠ¡ï¼‰ï¼Œè¿™ä¸ªå¼‚æ­¥æ“ä½œå¯èƒ½è¿˜æ²¡æœ‰ç«‹åˆ»è®¡ç®—å‡ºç»“æœã€‚
- `std::future` å°±æ˜¯å­˜å‚¨è¿™ä¸ªå°†æ¥è¦è®¡ç®—å‡ºç»“æœçš„å®¹å™¨ã€‚
- ä½ å¯ä»¥åœ¨éœ€è¦çš„æ—¶å€™ï¼Œé€šè¿‡ `std::future::get()` æ¥æ‹¿åˆ°ç»“æœã€‚
- å¦‚æœå¼‚æ­¥æ“ä½œå°šæœªå®Œæˆï¼Œé‚£ä¹ˆ `get()` ä¼šé˜»å¡çº¿ç¨‹ç›´åˆ°ç»“æœå‡†å¤‡å°±ç»ªã€‚
- å¦‚æœä¸éœ€è¦ç»“æœæˆ–ä»…ä»…æ£€æŸ¥ä»–æ˜¯å¦å®Œæˆï¼Œå¯ä»¥ä½¿ç”¨`future.wait_for()`ï¼Œ`future_wait_until()`ç­‰éé˜»å¡æˆ–è¶…æ—¶ç­‰å¾…ã€‚
```c
#include <iostream>
#include <future>
#include <thread>

int main() {
    // å¯åŠ¨ä¸€ä¸ªå¼‚æ­¥ä»»åŠ¡ï¼Œè¿”å›std::future
    std::future<int> fut = std::async(std::launch::async, [] {
        // æ¨¡æ‹Ÿè€—æ—¶è®¡ç®—
        std::this_thread::sleep_for(std::chrono::seconds(2));
        return 42;  // è®¡ç®—ç»“æœ
    });

    std::cout << "Doing something else...\n";

    // åœ¨éœ€è¦ç»“æœæ—¶ï¼Œå†è°ƒç”¨get()ï¼Œå¦‚æœä»»åŠ¡è¿˜æ²¡ç»“æŸå°±ä¼šåœ¨è¿™é‡Œé˜»å¡ç­‰å¾…
    int result = fut.get();
    std::cout << "Result is: " << result << std::endl;

    return 0;
}
```