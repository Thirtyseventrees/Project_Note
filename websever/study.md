
- [计网基础](#计网基础)
  - [IP地址](#ip地址)
    - [分类寻址](#分类寻址)
  - [子网掩码](#子网掩码)
- [操作系统基础](#操作系统基础)
  - [内存页（Memory Page）](#内存页memory-page)
    - [内存分页机制](#内存分页机制)
- [1. TCP/IP协议](#1-tcpip协议)
  - [1.1 TCP/IP协议族体系结构以及主要协议](#11-tcpip协议族体系结构以及主要协议)
    - [1.1.1 数据链路层](#111-数据链路层)
    - [1.1.2 网络层](#112-网络层)
    - [1.1.3 传输层](#113-传输层)
    - [1.1.4 应用层](#114-应用层)
  - [1.2 封装](#12-封装)
  - [1.3 分用](#13-分用)
  - [1.4 ARP协议工作原理](#14-arp协议工作原理)
  - [1.5 DNS工作原理](#15-dns工作原理)
  - [1.6 stocket和TCP/IP协议族的关系](#16-stocket和tcpip协议族的关系)
  - [网络层与传输层的联系：IP 与 TCP 的转换](#网络层与传输层的联系ip-与-tcp-的转换)
    - [1. 传输层（TCP）向下交付数据到网络层（IP）](#1-传输层tcp向下交付数据到网络层ip)
      - [示例：数据封装过程](#示例数据封装过程)
    - [2. 网络层（IP）向上传递数据到传输层（TCP）](#2-网络层ip向上传递数据到传输层tcp)
      - [示例：数据解封装过程](#示例数据解封装过程)
    - [3. 总结：IP 和 TCP 的关系](#3-总结ip-和-tcp-的关系)
    - [4. 示例：TCP/IP 数据封装](#4-示例tcpip-数据封装)
    - [5. 结论](#5-结论)
- [2. IP协议详解](#2-ip协议详解)
  - [2.1 IP服务的特点](#21-ip服务的特点)
  - [2.2 IPv4头部地址](#22-ipv4头部地址)
  - [2.3 IP分片](#23-ip分片)
  - [2.4 IP路由](#24-ip路由)
    - [2.4.1 IP模块工作流程](#241-ip模块工作流程)
    - [2.4.2 路由表](#242-路由表)
  - [2.5IP转发](#25ip转发)
  - [2.6 重定向](#26-重定向)
    - [2.6.1 ICMP重定向报文](#261-icmp重定向报文)
- [3. TCP协议详解](#3-tcp协议详解)
  - [3.1 TCP服务的特点](#31-tcp服务的特点)
  - [3.2 TCP头部结构](#32-tcp头部结构)
    - [3.2.1 TCP固定头部结构](#321-tcp固定头部结构)
    - [3.2.2 TCP头部选项](#322-tcp头部选项)
  - [3.3 TCP连接的建立和关闭](#33-tcp连接的建立和关闭)
    - [3.3.1 连接实验](#331-连接实验)
    - [3.3.2 半关闭状态](#332-半关闭状态)
    - [3.3.3 连接超时](#333-连接超时)
  - [3.4 TCP状态转移](#34-tcp状态转移)
    - [3.4.1 TIME\_WAIT状态](#341-time_wait状态)
  - [3.5 复位报文段](#35-复位报文段)
    - [3.5.1 访问不存在的端口](#351-访问不存在的端口)
    - [3.5.2 异常终止连接](#352-异常终止连接)
    - [3.5.3 处理半打开连接](#353-处理半打开连接)
  - [3.6 TCP超时重传](#36-tcp超时重传)
  - [3.7 拥塞控制](#37-拥塞控制)
    - [3.7.1 慢启动和拥塞避免](#371-慢启动和拥塞避免)
    - [3.7.2 快速重传和快速恢复](#372-快速重传和快速恢复)
- [4. Linux网络编程基础API](#4-linux网络编程基础api)
  - [4.1 socket地址API](#41-socket地址api)
    - [4.1.1 主机字节序和网络字节序](#411-主机字节序和网络字节序)
    - [4.1.2 通用socket地址](#412-通用socket地址)
    - [4.1.3 专用socket地址](#413-专用socket地址)
    - [4.1.4 IP地址转换函数](#414-ip地址转换函数)
    - [4.1.5 errno](#415-errno)
  - [4.2 创建socket](#42-创建socket)
  - [4.3 命名socket](#43-命名socket)
  - [4.4 监听socket](#44-监听socket)
  - [4.5 接受连接](#45-接受连接)
  - [4.6 TCP半连接队列和全连接队列](#46-tcp半连接队列和全连接队列)
  - [4.7 发起连接](#47-发起连接)
  - [4.8 关闭连接](#48-关闭连接)
  - [4.9 数据读写](#49-数据读写)
    - [4.9.1 TCP数据读写（`recv`和`send`）](#491-tcp数据读写recv和send)
    - [4.9.2 UDP数据读写](#492-udp数据读写)
    - [4.9.3 通用数据读写函数](#493-通用数据读写函数)
  - [4.10 地址信息函数](#410-地址信息函数)
  - [4.11 socket选项](#411-socket选项)
  - [4.12 网络信息API](#412-网络信息api)
  - [4.12.1 gethostbyname和gethostbyaddr](#4121-gethostbyname和gethostbyaddr)
  - [4.12.2 getservbyname和getservbyport](#4122-getservbyname和getservbyport)
- [文件描述符的引用计数](#文件描述符的引用计数)
- [5. 高级I/O函数](#5-高级io函数)
  - [5.1 pipe函数](#51-pipe函数)
  - [5.2 dup函数和dup2函数](#52-dup函数和dup2函数)
  - [5.3 readv函数和writev函数](#53-readv函数和writev函数)
  - [5.4 sendfile函数](#54-sendfile函数)
  - [5.5 mmap函数和munmap函数](#55-mmap函数和munmap函数)
  - [5.6 splice函数](#56-splice函数)
  - [5.7 tree函数](#57-tree函数)
  - [5.8 fcntl函数](#58-fcntl函数)
- [6. Linux服务器程序规范](#6-linux服务器程序规范)
- [9. IO复用](#9-io复用)
  - [9.1 select系统调用](#91-select系统调用)
    - [9.1.1 select API](#911-select-api)
    - [9.1.2 文件描述符就绪条件](#912-文件描述符就绪条件)
    - [9.1.3 处理带外数据](#913-处理带外数据)
- [9.2 poll系统调用](#92-poll系统调用)
- [9.3 epoll系列系统调用](#93-epoll系列系统调用)
  - [9.3.1 内核事件表, epoll\_create, epoll\_ctl](#931-内核事件表-epoll_create-epoll_ctl)
    - [9.3.2 epoll\_wait函数](#932-epoll_wait函数)
  - [9.3.3 LT和ET模式](#933-lt和et模式)
- [13. 多进程编程](#13-多进程编程)
  - [13.1 fork系统调用](#131-fork系统调用)
  - [13.2 exec系列系统调用](#132-exec系列系统调用)
  - [13.3 处理僵尸进程](#133-处理僵尸进程)
  - [13.4 管道](#134-管道)
  - [13.5 信号量](#135-信号量)
    - [13.5.1 信号量原语](#1351-信号量原语)
    - [13.5.2 `semget`系统调用](#1352-semget系统调用)
- [14. 多线程编程](#14-多线程编程)
  - [14.1 创建线程和结束线程](#141-创建线程和结束线程)
    - [14.1.1 `pthread_create`](#1411-pthread_create)
    - [14.1.2 `pthread_exit`](#1412-pthread_exit)
    - [14.1.3 `pthread_join`](#1413-pthread_join)
    - [14.1.4 `pthread_detach`](#1414-pthread_detach)
    - [14.1.5 `pthread_cancel`](#1415-pthread_cancel)
  - [14.2 线程属性](#142-线程属性)
  - [14.3 POSIX信号量](#143-posix信号量)
- [Http报文](#http报文)

# 计网基础

## IP地址
### 分类寻址
<img src="./picture/2.3.1.png" alt="implict_methods" width="600"/>   

A,B,C三类中前面的分类位和网络号是集中分配的，后面的主机位数是由站点决定的。  

## 子网掩码
通常用前缀长度表示（如/1，/8，/32...）表示前缀1的长度  
<img src="./picture/2-4.png" alt="implict_methods" width="600"/> 

通过将IP地址与掩码使用按位与的操作来确定一个IP地址的网络/子网部分的结束和主机部分的开始。

# 操作系统基础

## 内存页（Memory Page）
内存页（Memory Page） 是计算机内存管理的基本单位，操作系统将物理内存划分成 固定大小的块，这些块被称为页（Page）。  

现代操作系统使用 虚拟内存（Virtual Memory），它将进程的地址空间与物理内存进行映射。由于内存管理涉及大量数据的分配、回收，为了提高效率，操作系统按固定大小的“页”进行管理，而不是每次分配/释放任意大小的内存块。  

### 内存分页机制

内存管理使用分页（Paging）机制：
1. 虚拟地址：
   - 进程使用的地址空间是虚拟的，并不直接对应物理地址。
2. 页表：
   - 负责记录虚拟地址和物理地址之间的映射关系。
   - 每个进程都有自己的页表，操作系统通过页表来查找某个虚拟地址对应的物理内存。
3. 页面映射：
   - 当进程访问某个内存地址时，CPU先查找页表，找到对应的物理地址，然后访问物理内存。
4. 缺页异常：
   - 如果进程访问的虚拟地址没有映射到物理地址，则会触发缺页异常，操作系统会尝试加载该页。

# 1. TCP/IP协议
## 1.1 TCP/IP协议族体系结构以及主要协议
<img src="./picture/1-1.png" alt="implict_methods" width="600"/>  

### 1.1.1 数据链路层
 TCP/IP协议族中设计链路层的目的是为IP模块发送和接收IP数据报。
     
 数据链路层两个常用的协议是ARP协议（Address Resolve
Protocol，地址解析协议）和RARP协议（Reverse Address Resolve
Protocol，逆地址解析协议）。它们实现了IP地址和机器物理地址（通
常是MAC地址，以太网、令牌环和802.11无线网络都使用MAC地址）
之间的相互转换。  

网络层使用IP地址寻址一台机器，而数据链路层使用物理地址寻
址一台机器，因此网络层必须先将目标机器的IP地址转化成其物理地
址，才能使用数据链路层提供的服务，这就是ARP协议的用途。

---

### 1.1.2 网络层

网络层实现数据包的选路和转发。WAN（Wide Area Network，广
域网）通常使用众多分级的路由器来连接分散的主机或LAN（Local
Area Network，局域网），因此，通信的两台主机一般不是直接相连
的，而是通过多个中间节点（路由器）连接的。网络层的任务就是选
择这些中间节点，以确定两台主机之间的通信路径。  
**1. IP协议**  
网络层最核心的协议是IP协议（Internet Protocol，因特网协议）。
IP协议根据数据包的目的IP地址来决定如何投递它。如果数据包不能直
接发送给目标主机，那么IP协议就为它寻找一个合适的下一跳（next
hop）路由器，并将数据包交付给该路由器来转发。多次重复这一过
程，数据包最终到达目标主机，或者由于发送失败而被丢弃。可见，
IP协议使用逐跳（hop by hop）的方式确定通信路径。  
**2.ICMP协议**  
网络层另外一个重要的协议是ICMP协议（Internet Control Message
Protocol，因特网控制报文协议）。它是IP协议的重要补充，主要用于
检测网络连接。

<img src="./picture/1.1.2.2.png" alt="s" width="600"/>  

8位类型字段用于区分报文类型。它将ICMP报文分为两
大类：一类是差错报文，这类报文主要用来回应网络错误，比如目标
不可到达（类型值为3）和重定向（类型值为5）；另一类是查询报
文，这类报文用来查询网络信息，比如ping程序就是使用ICMP报文查
看目标是否可到达（类型值为8）的。（也就是说我们ping的时候使用的是ICMP协议）。  
工作原理  
1. 当你执行 `ping` 命令时，计算机会向目标主机发送 ICMP Echo Request（回显请求） 数据包。
2. 目标主机收到该请求后，会发送 ICMP Echo Reply（回显应答） 数据包作为响应。
3. 你的计算机接收到应答后，就能计算往返时间（RTT），并统计丢包率，从而判断网络连接情况。

---
### 1.1.3 传输层
传输层为两台主机上的应用程序提供端到端（end to end）的通
信。与网络层使用的逐跳通信方式不同，传输层只关心通信的起始端
和目的端，而不在乎数据包的中转过程。  

传输层协议主要有三个：TCP协议、UDP协议和SCTP协议。  

---
**1. TCP**  
TCP协议（Transmission Control Protocol，传输控制协议）为应用
层提供**可靠的、面向连接的和基于流（stream）的**服务。  

TCP协议使用**超时重传、数据确认**等方式来确保数据包被正确地发送至目的端，因此TCP服务是可靠的。  

使用TCP协议通信的双方必须先建立TCP连接，
并在内核中为该连接维持一些必要的数据结构，比如连接的状态、读
写缓冲区，以及诸多定时器等。当通信结束时，双方必须关闭连接以
释放这些内核数据。TCP服务是基于流的。基于流的数据没有边界（长
度）限制，它源源不断地从通信的一端流入另一端。发送端可以逐个
字节地向数据流中写入数据，接收端也可以逐个字节地将它们读出。

---
**2. UDP**  
UDP协议（User Datagram Protocol，用户数据报协议）则与TCP协
议完全相反，它为应用层提供不可靠、无连接和基于数据报的服
务。“**不可靠**”意味着UDP协议无法保证数据从发送端正确地传送到目
的端。如果数据在中途丢失，或者目的端通过数据校验发现数据错误
而将其丢弃，则UDP协议只是简单地通知应用程序发送失败。  

UDP协议是**无连接的**，即通信双方不保持一个长久的联系，因此
应用程序每次发送数据都要明确指定接收端的地址（IP地址等信
息）。

**基于数据报的服务**，是相对基于流的服务而言的。每个UDP数
据报都有一个长度，接收端必须以该长度为最小单位将其所有内容一
次性读出，否则数据将被截断。

---
### 1.1.4 应用层
应用层负责处理应用程序的逻辑。数据链路层、网络层和传输层
负责处理网络通信细节。应用层在用户空间实现。

---
## 1.2 封装
应用程序数据在发送到物理网络上之前，
将沿着协议栈从上往下依次传递。每层协议都将在上层数据的基础上
加上自己的头部信息（有时还包括尾部信息），以实现该层的功能，
这个过程就称为封装。  
<img src="./picture/1.2.1.png" alt="s" width="600"/>  

经过TCP封装后的数据称为TCP报文段（TCP message segment），
或者简称TCP段。  

TCP协议为通信双方维持一个连接，并且
在内核中存储相关数据。这部分数据中的TCP头部信息和TCP内核缓冲
区（发送缓冲区或接收缓冲区）数据一起构成了TCP报文段。

<img src="./picture/1.2.2.png" alt="s" width="600"/> 

当发送端应用程序使用send（或者write）函数向一个TCP连接写入
数据时，内核中的TCP模块首先把这些数据复制到与该连接对应的TCP
内核发送缓冲区中，然后TCP模块调用IP模块提供的服务，传递的参数
包括TCP头部信息和TCP发送缓冲区中的数据，即TCP报文段。  

经过UDP封装后的数据称为UDP数据报（UDP datagram）。UDP
对应用程序数据的封装与TCP类似。不同的是，UDP无须为应用层数据
保存副本，因为它提供的服务是不可靠的。`当一个UDP数据报被成功发送之后，UDP内核缓冲区中的该数据报就被丢弃了。`如果应用程序
检测到该数据报未能被接收端正确接收，并打算重发这个数据报，则
应用程序需要重新从用户空间将该数据报拷贝到UDP内核发送缓冲区
中。  

经过IP封装后的数据称为IP数据报（IP datagram）。IP数据报也包
括头部信息和数据部分，其中数据部分就是一个TCP报文段、UDP数据
报或者ICMP报文。  

经过数据链路层封装的数据称为**帧（frame）**。传输媒介不同，帧
的类型也不同。比如，以太网上传输的是以太网帧（ethernet frame），
而令牌环网络上传输的则是令牌环帧（token ring frame）。  

帧才是最终在物理网络上传送的字节序列。至此，封装过程完成。

## 1.3 分用

当帧到达目的主机时，将沿着协议栈自底向上依次传递。各层协
议依次处理帧中本层负责的头部数据，以获取所需的信息，并最终将
处理后的帧交给目标应用程序。这个过程称为分用
（demultiplexing）。

<img src="./picture/1.3.1.png" alt="s" width="600"/> 

因为IP协议、ARP协议和RARP协议都使用帧传输数据，所以帧的
头部需要提供某个字段（具体情况取决于帧的类型）来区分它们。  

同样，因为ICMP协议、TCP协议和UDP协议都使用IP协议，所以
IP数据报的头部采用16位的协议（protocol）字段来区分它们。  

TCP报文段和UDP数据报则通过其头部中的16位的端口号（port
number）字段来区分上层应用程序。比如DNS协议对应的端口号是
53，HTTP协议（Hyper-Text Transfer Protocol，超文本传送协议）对应
的端口号是80。  

## 1.4 ARP协议工作原理

（Address Resolve
Protocol，地址解析协议）

ARP协议能实现任意网络层地址到任意物理地址的转换，其工作原理
是：主机向自己所在的网络广播一个ARP请求，该请求包含目标机器
的网络地址。此网络上的其他机器都将收到这个请求，但只有被请求
的目标机器会回应一个ARP应答，其中包含自己的物理地址。  

通常，ARP维护一个高速缓存，其中包含经常访问（比如网关地
址）或最近访问的机器的IP地址到物理地址的映射。这样就避免了重
复的ARP请求，提高了发送数据包的速度。

## 1.5 DNS工作原理
我们通常使用机器的域名来访问这台机器，而不直接使用其IP地
址，比如访问因特网上的各种网站。那么如何将机器的域名转换成IP
地址呢？这就需要使用域名查询服务。域名查询服务有很多种实现方
式，比如NIS（Network Information Service，网络信息服务）、DNS和
本地静态文件等。本节主要讨论DNS。  
  
DNS是一套分布式的域名服务系统。每个DNS服务器上都存放着
大量的机器名和IP地址的映射，并且是动态更新的。众多网络客户端
程序都使用DNS协议来向DNS服务器查询目标主机的IP地址。

## 1.6 stocket和TCP/IP协议族的关系

数据链路层、网络层、传输层协议是在内核中实现
的。因此操作系统需要实现一组系统调用，使得应用程序能够访问这
些协议提供的服务。实现这组系统调用的API（Application
Programming Interface，应用程序编程接口）主要有两套：socket和
XTI。XTI现在基本不再使用，本书仅讨论socket。  

## 网络层与传输层的联系：IP 与 TCP 的转换

### 1. 传输层（TCP）向下交付数据到网络层（IP）
当应用程序（如 Web 浏览器）需要传输数据时：

1. **应用层** 发送数据给 **传输层**，传输层使用 TCP 进行可靠传输。
2. **TCP** 将数据分段（Segment），并为每个数据段添加 **TCP 头部**，包括 **源端口、目的端口、序列号、校验和** 等信息。
3. **TCP 数据段** 传递到 **网络层（IP）**，IP 会为其添加 **IP 头部**，包含 **源 IP、目的 IP、协议字段**（用于指示上层协议，如 TCP 或 UDP）。

#### 示例：数据封装过程
```text
应用层数据 -> TCP 头 + 数据 -> IP 头 + TCP 头 + 数据 -> 发送到链路层
```
IP 头的 **协议字段（Protocol）** 指定传输层协议类型：
- TCP：协议号 **6**
- UDP：协议号 **17**

---

### 2. 网络层（IP）向上传递数据到传输层（TCP）
当数据包到达目的主机时：

1. **数据链路层（如以太网）** 接收到数据帧，解析出 **IP 数据包** 交给 **网络层（IP）**。
2. **IP 层** 解析 **IP 头部**，根据 **目标 IP 地址** 判断是否是本机的数据，并检查 **协议字段**（如果是 6，则交给 TCP）。
3. **传输层（TCP）** 解析 **TCP 头部**，根据 **目的端口号** 交付给对应的应用程序（如 HTTP 服务器）。
4. 如果 TCP 需要确认数据的完整性，它会使用 **校验和**，并可能需要 **重传丢失的分段**。

#### 示例：数据解封装过程
```text
链路层帧 -> IP 头 + TCP 头 + 数据 -> 检查 IP 头部 -> TCP 头 + 数据 -> 交给 TCP 处理
```

---

### 3. 总结：IP 和 TCP 的关系
- **TCP 依赖 IP**：TCP 通过 IP 提供的寻址和路由功能，在网络中传输数据。
- **IP 依赖 TCP 或 UDP**：IP 只是一个 **无连接的、不可靠的** 传输机制，它需要传输层（如 TCP）来提供 **可靠传输**。
- **协议封装/解封装**：数据在传输过程中，IP 头和 TCP 头会被 **不断封装和解封装**，确保数据能够正确到达目标应用。

---

### 4. 示例：TCP/IP 数据封装
假设 **应用层（HTTP）** 发送 `GET /index.html` 请求，数据封装过程如下：

```text
[应用层数据] (HTTP 请求)
↓
[传输层] (TCP 头 + HTTP 数据)  # 例如：源端口 50000，目的端口 80
↓
[网络层] (IP 头 + TCP 头 + HTTP 数据)  # 例如：源 IP 192.168.1.1，目的 IP 10.0.0.2
↓
[数据链路层] (MAC 头 + IP 头 + TCP 头 + HTTP 数据)  # 例如：以太网帧
```
当数据到达目标主机后，解封装顺序相反，最终 **TCP 头解析端口号，交给对应应用处理 HTTP 请求**。

---

### 5. 结论
- IP 负责 **寻址和路由**，但不保证数据可靠。
- TCP 依赖 IP 进行数据传输，并提供 **可靠传输机制**（如 **确认应答、超时重传**）。
- 通过 **协议字段**（Protocol）和 **端口号** 进行转换，保证不同协议之间的数据能够正确交付给目标应用。

---

# 2. IP协议详解

IP协议是TCP/IP协议族的核心协议，也是socket网络编程的基础之
一。本章从两个方面较为深入地探讨IP协议：

- IP头部信息。IP头部信息出现在每个IP数据报中，用于指定IP通
信的源端IP地址、目的端IP地址，指导IP分片和重组，以及指定部分
通信行为。

- IP数据报的路由和转发。IP数据报的路由和转发发生在除目标
机器之外的所有主机和路由器上。它们决定数据报是否应该转发以及
如何转发。

## 2.1 IP服务的特点

IP协议是TCP/IP协议族的动力，它为上层协议提供**无状态**、**无连接**、**不可靠**的服务。

- 无状态（stateless）是指IP通信双方不同步传输数据的状态信息，
因此所有IP数据报的发送、传输和接收都是相互独立、没有上下文关
系的。  
这种服务最大的缺点是无法处理乱序和重复的IP数据报。比如
发送端发送出的第N个IP数据报可能比第N+1个IP数据报后到达接收
端，而同一个IP数据报也可能经过不同的路径多次到达接收端。在这
两种情况下，接收端的IP模块无法检测到乱序和重复，因为这些IP数
据报之间没有任何上下文关系。接收端的IP模块只要收到了完整的IP
数据报（如果是IP分片的话，IP模块将先执行重组），就将其数据部
分（TCP报文段、UDP数据报或者ICMP报文）上交给上层协议。那么
从上层协议来看，这些数据就可能是乱序的、重复的。面向连接的协
议，比如TCP协议，则能够自己处理乱序的、重复的报文段，它递交
给上层协议的内容绝对是有序的、正确的。

- 无连接（connectionless）是指IP通信双方都不长久地维持对方的
任何信息。这样，上层协议每次发送数据的时候，都必须明确指定对
方的IP地址。

- 不可靠是指IP协议不能保证IP数据报准确地到达接收端，它只是
承诺尽最大努力（best effort）。很多种情况都能导致IP数据报发送失
败。比如，某个中转路由器发现IP数据报在网络上存活的时间太长
（根据IP数据报头部字段TTL判断，见后文），那么它将丢弃之，并
返回一个ICMP错误消息（超时错误）给发送端。  
无论哪种情况，发送
端的IP模块一旦检测到IP数据报发送失败，就通知上层协议发送失
败，而不会试图重传。因此，使用IP服务的上层协议（比如TCP协
议）需要自己实现数据确认、超时重传等机制以达到可靠传输的目
的。

## 2.2 IPv4头部地址
<img src="./picture/2.2.1.png" alt="s"/>

- 4位版本号（version）指定IP协议的版本。对IPv4来说，其值是4。
其他IPv4协议的扩展版本（如SIP协议和PIP协议），则具有不同的版本
号（它们的头部结构也和图2-1不同）。
<br>
<br>
- 4位头部长度（header length）标识该IP头部有多少个32 bit字（4字
节）。因为4位最大能表示15，所以IP头部最长是60字节。
<br>
<br>
- 8位服务类型（Type Of Service，TOS）包括一个3位的优先权字段
（现在已经被忽略），4位的TOS字段和1位保留字段（必须置0）。4位
的TOS字段分别表示：最小延时，最大吞吐量，最高可靠性和最小费
用。其中最多有一个能置为1，应用程序应该根据实际需要来设置它。
比如像ssh和telnet这样的登录程序需要的是最小延时的服务，而文件传
输程序ftp则需要最大吞吐量的服务。
<br>
<br>
- 16位总长度（total length）是指整个IP数据报的长度，以字节为单
位，因此IP数据报的最大长度为65 535（2
16-1）字节。但由于MTU的
限制，长度超过MTU的数据报都将被分片传输，所以实际传输的IP数
据报（或分片）的长度都远远没有达到最大值。(MTU是在链路层中帧的最大传输单元（见1.2）)
<br>
<br>
- 接下来的3个字段则描述了如何实现分片。（即图中第二行）
- 1. 16位标识（identification）唯一地标识主机发送的每一个数据报。
其初始值由系统随机生成；每发送一个数据报，其值就加1。该值在数
据报分片时被复制到每个分片中，因此同一个数据报的所有分片都具
有相同的标识值。
- 2. 3位标志字段的第一位保留。第二位（Don’t Fragment，DF）表
示“禁止分片”。如果设置了这个位，IP模块将不对数据报进行分片。在
这种情况下，如果IP数据报长度超过MTU的话，IP模块将丢弃该数据
报并返回一个ICMP差错报文。第三位（More Fragment，MF）表示“更
多分片”。除了数据报的最后一个分片外，其他分片都要把它置1。
- 3. 13位分片偏移（fragmentation offset）是分片相对原始IP数据报开
始处（仅指数据部分）的偏移。实际的偏移值是该值左移3位（乘8）
后得到的。由于这个原因，除了最后一个IP分片外，每个IP分片的数据
部分的长度必须是8的整数倍（这样才能保证后面的IP分片拥有一个合
适的偏移值）。
<br>
<br>
- 8位生存时间（Time To Live，TTL）是数据报到达目的地之前允许
经过的路由器跳数。TTL值被发送端设置（常见的值是64）。数据报在
转发过程中每经过一个路由，该值就被路由器减1。当TTL值减为0时，
路由器将丢弃数据报，并向源端发送一个ICMP差错报文。TTL值可以
防止数据报陷入路由循环。
<br>
<br>
- 8位协议（protocol）用来区分上层协议，我们在第1章讨论
过。/etc/protocols文件定义了所有上层协议对应的protocol字段的数值。
其中，ICMP是1，TCP是6，UDP是17。/etc/protocols文件是RFC 1700的
一个子集。
<br>
<br>
- 16位头部校验和（header checksum）由发送端填充，接收端对其
使用CRC算法以检验IP数据报头部（注意，仅检验头部）在传输过程
中是否损坏。
<br>
<br>
- 32位的源端IP地址和目的端IP地址用来标识数据报的发送端和接收
端。一般情况下，这两个地址在整个数据报的传递过程中保持不变，
而不论它中间经过多少个中转路由器。
<br>
<br>
- IPv4最后一个选项字段（option）是可变长的可选信息。这部分最
多包含40字节，因为IP头部最长是60字节（其中还包含前面讨论的20
字节的固定部分）。

## 2.3 IP分片
当IP数据报的长度超过帧的MTU时，它将被分片传
输。分片可能发生在发送端，也可能发生在中转路由器上，而且可能
在传输过程中被多次分片，但只有在最终的目标机器上，这些分片才
会被内核中的IP模块重新组装。

---
**注意：** 在IP网络中，分片可能发生在发送端，也可能发生在中转路由器，其主要原因在于 路径MTU（Path MTU, PMTU）可能在不同的链路上有所不同。具体而言：

1. 发送端并不一定知道完整的路径MTU：  
    - 在IPv4中，默认情况下，发送端不会主动探测整个路径上的最小MTU，而是根据本地接口的MTU来决定是否分片。
    - 但是，网络路径可能会经过多个不同的网络，每个网络的MTU可能不同。例如：
    发送端所在的本地网络可能支持 1500 字节（典型的以太网MTU）。
    但是中转路由器可能连接一个 MTU 只有 1400 字节的链路。
    由于IP数据报在传输时遵循“逐跳转发”（hop-by-hop forwarding），当数据报进入 MTU 更小的网络时，中转路由器必须对其进行分片。
    
2. 路径上的 MTU 可能动态变化：

    网络路径可能包含多种不同的链路技术（如以太网、PPP、无线网络等），它们的MTU各不相同。
    例如，一个数据报可能在 1500 字节 MTU 的链路上传输，但随后经过一个只有 576 字节 MTU 的链路，路由器必须分片，否则数据包无法通过。

3. IPv4 不强制要求 PMTU 发现机制：

    虽然 IPv4 支持 Path MTU Discovery (PMTUD) 机制（通过 ICMP “Fragmentation Needed” 消息通知发送端降低数据包大小），但许多网络会 丢弃 ICMP 消息（出于安全策略或防火墙配置），导致 PMTUD 不能可靠工作。
    由于发送端可能并不知道实际的路径MTU，因此只能基于本地MTU发送较大数据报，而在中转路由器上进行分片。

4. 某些情况下，发送端无法预见后续链路的 MTU 限制：  
   
    在 隧道（Tunneling） 环境下，数据包可能被封装，例如 VPN、GRE、IPsec 隧道等，这些封装会引入额外的头部，导致有效的MTU降低，进而引发分片。
---

IP头部中的如下三个字段给IP的分片和重组提供了足够的信息：数据报标识（16位）、标志（3位）和片偏移（13位）。一个IP数据报的每个分片都
- 有自己的IP头部，
- 它们具有相同的标识值，
- 但具有不同的片偏移。
- 并且除了最后一个分片外，其他分片都将设置MF标志。
- 此外，每个分片的IP头部的总长度字段将被设置为该分片的长度

<img src="./picture/2.3._1.png" alt="s"/>

图2-2中，长度为1501字节的IP数据报被拆分成两个IP分片，第一个IP分片长度为1500字节，第二个IP分片的长度为21字节。每个IP分片都包含IP头部（20字节），且第一个IP分片的IP头部设置了MF标志，而第二个IP分片的IP头部则没有设置该标志，因为它已经是最后一个分片了。  

原始IP数据报中的ICMP头部内容被完整地复制到了第一个IP分片中。`第二个IP分片不包含ICMP头部信息`，因为IP模块重组该ICMP报文的时候只需要一份ICMP头部信息，重复传送这个信息没有任何益处。  

最后，IP层传递给数据链路层的数据可能是一个完整的IP数据报，也可能是一个IP分片，它们统称为IP分组（packet）。

## 2.4 IP路由

IP协议的一个核心任务是数据报的路由，即决定发送数据报到目标机器的路径。为了理解IP路由过程，我们先简要分析IP模块的基本工作流程。

### 2.4.1 IP模块工作流程

<img src="./picture/2.4.1.1.png" alt="s" width = "800"/>

**注意：** 在该图的IP模块基本工作流程中，数据报在进入 IP 模块后，首先会判断它是否是发往本机的。如果是发往本机的，则数据报会进入IP输入队列，然后交由上层协议（如 TCP、UDP）处理。但是，图中仍然存在一条指向“计算下一跳路由”的路径，这可能有以下几种情况导致数据继续转发：

1. 处理 IP 头部选项（IP 选项可能要求继续转发）
IP 头部可能包含一些特殊选项，例如：

- “宽松源路由”（Loose Source Routing）：指示数据包必须经过特定的一系列路由节点，但允许它经过其他节点。
- “严格源路由”（Strict Source Routing）：要求数据包严格按照指定的路径传输，而不能经过其他中间节点。
如果 IP 头部包含这些选项，则本机需要解析这些信息，并根据选项的要求可能将数据包继续转发到下一跳，而不是直接交给上层协议处理。

2. 数据包可能是 ICMP 重定向的目标
- 如果数据包是 ICMP 重定向（ICMP Redirect）类型的消息，本机可能需要按照新的路径转发数据，而不是直接处理它。
- 例如，主机在默认网关收到 ICMP 重定向后，可能会重新计算下一跳，而不是由本机终止数据包的处理。
3. 本机可能是某种网络设备（如路由器）
如果设备不仅仅是终端，而是充当路由器的角色，那么它既可以接收数据包，也可以转发某些数据包。例如：

- 某些数据包是发往本机，但本机是 NAT 网关，需要进行地址转换并将其转发到内部网络。
- 本机充当 代理（proxy）或网桥（bridge），可能会根据不同的协议要求对数据进行转发。
4. 隧道（Tunneling）机制
如果本机运行了一些 隧道协议（如 GRE、IPsec、6to4 等），数据包到达本机后，可能需要进行 解封装，然后将其继续转发到目的地，而不是直接交给本机的上层协议。

### 2.4.2 路由表
路由表是一张存储在路由器或主机上的数据表，它用于决定数据包的转发路径。当 IP 数据包到达设备时，设备会查询路由表，以确定应该将数据包转发到哪个下一跳（Next Hop）或直接交给本机处理。

|   **字段**	|   **描述**   |  
|--------------|---------------|
|目标网络（Destination）|	目标 IP 地址或子网，例如 192.168.1.0/24|
|子网掩码（Netmask）|	用于确定目标网络的范围，例如 255.255.255.0|
|下一跳（Next Hop）|	数据包应该被转发到的下一个路由器 IP，例如 192.168.1.1|
|出接口（Interface）|	发送数据包的网络接口，如 eth0 或 wlan0|
|度量值（Metric）|	该路由的优先级，数字越小表示优先级越高|

**路由表的查询过程**  

当设备收到一个数据包时，它会按照以下步骤查询路由表：

1. 匹配精确的目标地址
   - 例如，数据包目的地是 192.168.1.50，首先匹配 192.168.1.0/24 。
2. 查找最优匹配（最长前缀匹配，Longest Prefix Match, LPM）
   - 如果有多个匹配项，选择子网掩码最长的（即最具体的）。
3. 确定下一跳
   - 如果找到匹配路由，查找 Next Hop 并转发数据包。
4. 如果没有匹配，使用默认路由
   - 如果没有明确的匹配项，就使用默认路由（如果存在）。
5. 如果没有默认路由，则丢弃数据包
   - 设备可能返回 ICMP "Destination Unreachable" 错误。

## 2.5IP转发
前文提到，不是发送给本机的IP数据报将由数据报转发子模块来处理。路由器都能执行数据报的转发操作，而主机一般只发送和接收数据报，这是因为主机上/proc/sys/net/ipv4/ip_forward内核参数默认被设置为0。我们可以通过修改它来使能主机的数据报转发功能。  

对于允许IP数据报转发的系统（主机或路由器），数据报转发子模块将对期望转发的数据报执行如下操作：
1. 检查数据报头部的TTL值。如果TTL值已经是0，则丢弃该数据报。
2. 查看数据报头部的严格源路由选择选项。如果该选项被设置，则检测数据报的目标IP地址是否是本机的某个IP地址。如果不是，则发送一个ICMP源站选路失败报文给发送端。
3. 如果有必要，则给源端发送一个ICMP重定向报文，以告诉它一个更合理的下一跳路由器。
4. 将TTL值减1。
5. 处理IP头部选项。
6. 如有必要，则执行IP分片操作。

## 2.6 重定向

ICMP重定向报文也能用于更新路由表，因此本节我们简要讨论ICMP重定向。

### 2.6.1 ICMP重定向报文
<img src="./picture/2.6.1.png" alt="s" width = "700"/>
  
<br>
ICMP重定向报文的类型值是5，代码字段有4个可选值，用来区分不同的重定向类型。本书仅讨论主机重定向，其代码
值为1。  
<br>
<br>
ICMP重定向报文的数据部分含义很明确，它给接收方提供了如下两个信息:

1. 引起重定向的IP数据报（即图中的原始IP数据报）的源端IP地址。
2. 应该使用的路由器IP地址。

接收主机根据这两个信息就可以断定引起重定向的IP数据报应该使用哪个路由器来转发，并且以此来更新路由表（通常是更新路由表缓冲，而不是直接更改路由表）。

# 3. TCP协议详解
本章从如下四方面来讨论TCP协议：
1. TCP头部信息。TCP头部信息出现在每个TCP报文段中，用于指定通信的源端端口号、目的端端口号，管理TCP连接，控制两个方向的数据流。
2. TCP状态转移过程。TCP连接的任意一端都是一个状态机。在TCP连接从建立到断开的整个过程中，连接两端的状态机将经历不同的状态变迁。
3. TCP数据流。通过分析TCP数据流，我们就可以从网络应用程序外部来了解应用层协议和通信双方交换的应用程序数据。这一部分将讨论两种类型的TCP数据流：交互数据流和成块数据流。TCP数据流中有一种特殊的数据，称为紧急数据，我们也将简单讨论之。
4. TCP数据流的控制。为了保证可靠传输和提高网络通信质量，内核需要对TCP数据流进行控制。这一部分讨论TCP数据流控制的两个方面：超时重传和拥塞控制。

## 3.1 TCP服务的特点
传输层协议主要有两个：TCP协议和UDP协议。TCP协议相对于UDP协议的特点是：面向连接、字节流和可靠传输。   
<br>
使用TCP协议通信的双方必须先建立连接，然后才能开始数据的读写。双方都必须为该连接分配必要的内核资源，以管理连接的状态和连接上数据的传输。TCP连接是全双工的，即双方的数据读写可以通过一个连接进行。完成数据交换之后，通信双方都必须断开连接以释放系统资源。  

TCP协议的这种连接是一对一的，所以基于广播和多播（目标是多个主机地址）的应用程序不能使用TCP服务。而无连接协议UDP则非常适合于广播和多播。  

我们在1.1节中简单介绍过字节流服务和数据报服务的区别。这种区别对应到实际编程中，则体现为通信双方是否必须执行相同次数的读、写操作（当然，这只是表现形式）。当发送端应用程序连续执行多次写操作时，TCP模块先将这些数据放入TCP发送缓冲区中。`当TCP模块真正开始发送数据时，发送缓冲区中这些等待发送的数据可能被封装成一个或多个TCP报文段发出。`因此，TCP模块发送出的TCP报文段的个数和应用程序执行的写操作次数之间没有固定的数量关系。  

当接收端收到一个或多个TCP报文段后，`TCP模块将它们携带的应用程序数据按照TCP报文段的序号（见后文）依次放入TCP接收缓冲区中`，并通知应用程序读取数据。`接收端应用程序可以一次性将TCP接收缓冲区中的数据全部读出，也可以分多次读取`，这取决于用户指定的应用程序读缓冲区的大小。因此，应用程序执行的读操作次数和TCP模块接收到的TCP报文段个数之间也没有固定的数量关系。

综上所述，发送端执行的写操作次数和接收端执行的读操作次数之间没有任何数量关系，这就是字节流的概念：应用程序对数据的发
送和接收是没有边界限制的。UDP则不然。发送端应用程序每执行一次写操作，UDP模块就将其封装成一个UDP数据报并发送之。接收端必须及时针对每一个UDP数据报执行读操作（通过recvfrom系统调用），否则就会丢包（这经常发生在较慢的服务器上）。并且，如果用户没有指定足够的应用程序缓冲区来读取UDP数据，则UDP数据将被截断。

<img src="./picture/3.1.1.png" alt="s" width = "700"/>  
  
TCP传输是可靠的。首先，TCP协议采用发送`应答机制`，即发送端发送的每个TCP报文段都必须得到接收方的应答，才认为这个TCP报文段传输成功。其次，TCP协议采用`超时重传机制`，发送端在发送出一个TCP报文段之后启动定时器，如果在定时时间内未收到应答，它将重发该报文段。最后，因为TCP报文段最终是以IP数据报发送的，而IP数据报到达接收端可能乱序、重复，所以TCP协议还会`对接收到的TCP报文段重排、整理，再交付给应用层`。  

## 3.2 TCP头部结构
TCP头部信息出现在每个TCP报文段中，用于指定通信的源端端口，目的端端口，管理TCP连接等，本节详细介绍TCP的头部结构，包
括固定头部结构和头部选项。  

### 3.2.1 TCP固定头部结构
<img src="./picture/3.2.1.1.png" width = "700">  

1. 16位端口号(65536)（port number）：告知主机该报文段是来自哪里（源端口）以及传给哪个上层协议或应用程序（目的端口）的。进行TCP通
信时，客户端通常使用系统自动选择的临时端口号，而服务器则使用知名服务端口号。1.3节中提到过，所有知名服务使用的端口号都定义在/etc/services文件中。  

2. 32位序号（sequence number）：一次TCP通信（从TCP连接建立到断开）过程中某一个传输方向上的字节流的每个字节的编号。假设主
机A和主机B进行TCP通信，A发送给B的第一个TCP报文段中，序号值被系统初始化为某个随机值ISN（Initial Sequence Number，初始序号值）。那么在该传输方向上（从A到B），后续的TCP报文段中序号值将被系统设置成ISN加上该报文段所携带数据的第一个字节在整个字节流中的偏移。例如，某个TCP报文段传送的数据是字节流中的第1025～2048字节，那么该报文段的序号值就是ISN+1025。另外一个传输方向（从B到A）的TCP报文段的序号值也具有相同的含义。

3. 32位确认号（acknowledgement number）：用作对另一方发送来的TCP报文段的响应。其值是收到的TCP报文段的序号值加1。假设主机A和主机B进行TCP通信，那么A发送出的TCP报文段不仅携带自己的序号，而且包含对B发送来的TCP报文段的确认号。反之，B发送出的TCP报文段也同时携带自己的序号和对A发送来的报文段的确认号。

---
**TCP 32 位确认号（Acknowledgement Number）解析**
TCP（传输控制协议）是面向连接的协议，它通过序号（Sequence Number）和确认号（Acknowledgement Number） 来保证数据可靠传输。

1. 确认号（ACK Number）的定义
在 TCP 头部中，确认号字段（Acknowledgement Number）占 32 位，用于确认接收方已经成功接收的数据。

   - 确认号的值：表示期望收到的下一个字节的序列号。
   - 计算方式：如果主机 A 收到主机 B 发送的数据，数据的 最后一个字节的序列号 + 1 作为返回给 B 的确认号。
2. 确认号的工作机制
假设主机 A 和主机 B 进行 TCP 连接，A 发送数据，B 确认接收并回复：

- 第一步（A → B）：A 发送数据

  - A 发送：带有 Sequence Number = 1000，数据长度为 100 字节。
  - B 接收：成功接收后，计算 确认号 = 1000 + 100 = 1100。
- 第二步（B → A）：B 发送 ACK 确认

  - B 发送 ACK：Acknowledgement Number = 1100，告诉 A 之前的数据已经收到，期待下一个字节的序列号是 1100。
  - A 收到 B 的 ACK 后，知道数据成功传输。
---

4. 4位头部长度（header length）：标识该TCP头部有多少个32bit字（4字节）。因为4位最大能表示15，所以TCP头部最长是60字节。  

5. 6位标志位包含如下几项：

    | **标志位** | **缩写** | **作用** |
    |-----------|---------|---------|
    | 紧急指针 | **URG** | 表示数据有更高优先级，需要立即处理 |
    | 确认位 | **ACK** | 确认收到对方的数据，ACK=1 时确认号有效 |
    | 推送位 | **PSH** | 立即将数据交付给应用层，而不等待缓冲区填满 |
    | 复位位 | **RST** | 强制断开 TCP 连接，通常用于异常情况 |
    | 同步位 | **SYN** | 用于建立连接，三次握手时使用 |
    | 终止位 | **FIN** | 用于断开连接，四次挥手时使用 |

6. 16位窗口大小（window size）：是TCP流量控制的一个手段。这里说的窗口，指的是接收通告窗口（Receiver Window，RWND）。它告
诉对方本端的TCP接收缓冲区还能容纳多少字节的数据，这样对方就可以控制发送数据的速度。

7. 16位校验和（TCP checksum）：由发送端填充，接收端对TCP报文段执行CRC算法以检验TCP报文段在传输过程中是否损坏。注意，这
个校验不仅包括TCP头部，也包括数据部分。这也是TCP可靠传输的一个重要保障。

8. 16位紧急指针（urgent pointer）：是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。因此，确切地
说，这个字段是紧急指针相对当前序号的偏移，不妨称之为紧急偏移。TCP的紧急指针是发送端向接收端发送紧急数据的方法。我们将在后面讨论TCP紧急数据。

### 3.2.2 TCP头部选项
<img src="./picture/3.2.2.1.png" width="700">

选项的第一个字段kind说明选项的类型。有的TCP选项没有后面两个字段，仅包含1字节的kind字段。第二个字段length（如果有的话）指定该选项的总长度，该长度包括kind字段和length字段占据的2字节。第三个字段info（如果有的话）是选项的具体信息。常见的TCP选项有7种，如下图所示。

<img src="./picture/3.2.2.2.png" width="700">

- kind=0是选项表结束选项。
- kind=1是空操作（nop）选项，没有特殊含义，一般用于将TCP选项的总长度填充为4字节的整数倍。
- kind=2是最大报文段长度选项。TCP连接初始化时，通信双方使用该选项来协商最大报文段长度（Max Segment Size，MSS）。TCP模块通常将MSS设置为（MTU-40）字节（减掉的这40字节包括20字节的TCP头部和20字节的IP头部）。这样携带TCP报文段的IP数据报的长度就不会超过MTU（假设TCP头部和IP头部都不包含选项字段，并且这也是一般情况），从而避免本机发生IP分片。对以太网而言，MSS值是1460（1500-40）字节。
- kind=3是窗口扩大因子选项。TCP连接初始化时，通信双方使用该选项来协商接收通告窗口的扩大因子。在TCP的头部中，接收通告窗口大小是用16位表示的，故最大为65 535字节，但实际上TCP模块允许的接收通告窗口大小远不止这个数（为了提高TCP通信的吞吐量）。窗口扩大因子解决了这个问题。假设TCP头部中的接收通告窗口大小是N，窗口扩大因子（移位数）是M，那么TCP报文段的实际接收通告窗口大小是N乘2M，或者说N左移M位。注意，M的取值范围是0～14.和MSS选项一样，窗口扩大因子选项只能出现在同步报文段中，否则将被忽略。

## 3.3 TCP连接的建立和关闭

<img src="./picture/3.3.1.1.png" width="700">  

### 3.3.1 连接实验
windows端使用ncat监听12345端口  
```
.\ncat.exe -lvp 12345
```
linux使用nc连接并监听来自windows的通信
```
sudo tcpdump -i eth0 -nt host 192.168.0.146
nc 192.168.0.146 12345
```
在linux上监听结果如下  
(注：172.23.197.6为linux地址，192.168.0.146为windows地址)
linux连接时（三次握手）
```
IP 172.23.197.6.49912 > 192.168.0.146.12345: Flags [S], seq 851791602, win 64240, options [mss 1460,sackOK,TS val 3774026442 ecr 0,nop,wscale 7], length 0
IP 192.168.0.146.12345 > 172.23.197.6.49912: Flags [S.], seq 1652858308, ack 851791603, win 65535, options [mss 65495,nop,wscale 8,sackOK,TS val 19426092 ecr 3774026442], length 0
IP 172.23.197.6.49912 > 192.168.0.146.12345: Flags [.], ack 1, win 502, options [nop,nop,TS val 3774026442 ecr 19426092], length 0
```
在linux输入hello并发送之后
```
IP 172.23.197.6.49912 > 192.168.0.146.12345: Flags [P.], seq 1:7, ack 1, win 502, options [nop,nop,TS val 3774347740 ecr 19426092], length 6
IP 192.168.0.146.12345 > 172.23.197.6.49912: Flags [.], ack 7, win 8195, options [nop,nop,TS val 19747389 ecr 3774347740], length 0
```
在windows上输入hi并发送之后
```
IP 192.168.0.146.12345 > 172.23.197.6.49912: Flags [P.], seq 1:4, ack 7, win 8195, options [nop,nop,TS val 19820653 ecr 3774347740], length 3
IP 172.23.197.6.49912 > 192.168.0.146.12345: Flags [.], ack 4, win 502, options [nop,nop,TS val 3774421004 ecr 19820653], length 0
```
在linux上`ctrl + c`断开连接之后（四次挥手）
```
IP 172.23.197.6.49912 > 192.168.0.146.12345: Flags [F.], seq 7, ack 4, win 502, options [nop,nop,TS val 3774468685 ecr 19820653], length 0
IP 192.168.0.146.12345 > 172.23.197.6.49912: Flags [.], ack 8, win 8195, options [nop,nop,TS val 19868335 ecr 3774468685], length 0
IP 192.168.0.146.12345 > 172.23.197.6.49912: Flags [F.], seq 4, ack 8, win 8195, options [nop,nop,TS val 19868335 ecr 3774468685], length 0
IP 172.23.197.6.49912 > 192.168.0.146.12345: Flags [.], ack 5, win 502, options [nop,nop,TS val 3774468685 ecr 19868335], length 0
```
---
1. 连接
- 连接建立时，第一个TCP报文段包含SYN标志，因此它是一个同步报文段(`Flags[S]`)，即客户端向服务器发起连接请求，该同步报文包含一个ISN值的序列号(`seq`)。  
- 第二个TCP报文段也是同步报文段，表示服务端同意与客户端建立连接。同时发送自己的ISN值的序列号，并对第一个同步报文段进行确认(`ack`)。  
- 第三个TCP报文是客户端对第二个同步报文段的确认。至此，TCP连接就建立起来了。建立TCP连接的这三个步骤就被称为TCP的三次握手。
2. 断开
- 第一个TCP报文包含`FIN`标志，因此它是一个结束报文段，即客户端要求关闭连接。
- 之后服务端向客户端发出报文段来确认服务端发出的结束报文段。
- 紧接着服务端发送自己的结束报文段。
- 最后客户端发送报文段给服务端以确认服务端的结束报文段  

注：实际上第二个仅用于确认的报文段是可以省略的，因为第三个服务端发出的结束报文段也携带了该确认信息。第二个报文段是否出现在连接断开的过程中，取决于TCP的`延迟确认特性`。

一般而言，TCP连接是由客户端发起，并通过三次握手建立（特殊情况是所谓同时打开）的。TCP连接的关闭过程相对复杂一些。可能是客户端执行主动关闭，比如前面的例子；也可能是服务器执行主动关闭，比如服务器程序被中断而强制关闭连接；还可能是同时关闭（和同时打开一样，非常少见）。

### 3.3.2 半关闭状态

TCP连接是全双工的，所以它允许两个方向的数据传输被独立关闭。换言之，通信的一端可以发送结束报文段给对方，告诉它本端已经完成了数据的发送，但允许继续接收来自对方的数据，直到对方也发送结束报文段以关闭连接。TCP连接的这种状态称为半关闭（half close）状态。

<img src="./picture/3.3.2.1.png" width="700">  

### 3.3.3 连接超时

如果客户端访问一个距离它很远的服务器，或者由于网络繁忙，导致服务器对于客户端发送出的同步报文段没有应答，此时客户端程序将产生什么样的行为呢？显然，对于提供可靠服务的TCP来说，它必然是先进行重连（可能执行多次），如果重连仍然无效，则通知应用程序连接超时。  

## 3.4 TCP状态转移

<img src="./picture/3.4.1.png" width="700"> 

当客户端执行主动关闭时，它将向服务器发送一个结束报文段，同时连接进入FIN_WAIT_1状态。若此时客户端收到服务器专门用于确
认目的的确认报文段（比如图3-6中的TCP报文段5），则连接转移至FIN_WAIT_2状态。当客户端处于FIN_WAIT_2状态时，服务器处于CLOSE_WAIT状态，这一对状态是可能发生半关闭的状态。此时如果服务器也关闭连接（发送结束报文段），则客户端将给予确认并进入TIME_WAIT状态。

<img src="./picture/3.4.2.png" width="700"> 

### 3.4.1 TIME_WAIT状态

从上图来看，客户端连接在收到服务器的结束报文段（TCP报文段6）之后，并没有直接进入CLOSED状态，而是转移到TIME_WAIT状态。在这个状态，客户端连接要`等待一段长为2MSL（MaximumSegment Life，报文段最大生存时间）的时间`，才能完全关闭。MSL是TCP报文段在网络中的最大生存时间，标准文档RFC 1122的建议值是2min。  

原因有两点：

1. 可靠地终止TCP连接。  
    假设图中用于确认服务器结束报文段6的TCP报文段7丢失，那么服务器将重发结束报文段。因此客户端需要停留在某个状态以处理重复收到的结束报文段（即向服务器发送确认报文段）。否则，客户端将以复位报文段来回应服务器，服务器则认为这是一个错误，因为它期望的是一个像TCP报文段7那样的确认报文段。

2. 保证让迟来的TCP报文段有足够的时间被识别并丢弃。

在Linux系统上，一个TCP端口不能被同时打开多次（两次及以上）。当一个TCP连接处于TIME_WAIT状态时，我们将无法立即使用该连接占用着的端口来建立一个新连接。

## 3.5 复位报文段

在某些特殊条件下，TCP连接的一端会向另一端发送携带RST标志的报文段，即复位报文段，以通知对方关闭连接或重新建立连接。本节讨论产生复位报文段的3种情况。

### 3.5.1 访问不存在的端口

当客户端程序访问一个不存在的端口时，目标主机将给它发送一个复位报文段。  
当客户端程序向服务器的某个端口发起连接，而该端口仍被处于TIME_WAIT状态的连接所占用时，客户端程序也将收到复位报文段。

### 3.5.2 异常终止连接

前面讨论的连接终止方式都是正常的终止方式：数据交换完成之后，一方给另一方发送结束报文段。TCP提供了异常终止一个连接的方法，即给对方发送一个复位报文段。一旦发送了复位报文段，发送端所有排队等待发送的数据都将被丢弃。应用程序可以使用socket选项SO_LINGER来发送复位报文段，以异常终止一个连接。

### 3.5.3 处理半打开连接

考虑下面的情况：服务器（或客户端）关闭或者异常终止了连接，而对方没有接收到结束报文段（比如发生了网络故障），此时，客户端（或服务器）还维持着原来的连接，而服务器（或客户端）即使重启，也已经没有该连接的任何信息了。我们将这种状态称为半打开状态，处于这种状态的连接称为半打开连接。如果客户端（或服务器）往处于半打开状态的连接写入数据，则对方将回应一个复位报文段。

## 3.6 TCP超时重传

异常网络状况下（开始出现超时或丢包），TCP如何控制数据传输以保证其承诺的可靠服务。  

TCP服务必须能够重传超时时间内未收到确认的TCP报文段。为此，TCP模块为每个TCP报文段都维护一个重传定时器，该定时器在TCP报文段第一次被发送时启动。如果超时时间内未收到接收方的应答，TCP模块将重传TCP报文段并重置定时器。至于下次重传的超时时间如何选择，以及最多执行多少次重传，就是TCP的重传策略。

## 3.7 拥塞控制

TCP模块还有一个重要的任务，就是提高网络利用率，降低丢包率，并保证网络资源对每条数据流的公平性。这就是所谓的拥塞控制。

TCP拥塞控制的标准文档是RFC 5681，其中详细介绍了拥塞控制的四个部分：慢启动（slow start）、拥塞避免（congestionavoidance）、快速重传（fast retransmit）和快速恢复（fastrecovery）。

拥塞控制的最终受控变量是发送端向网络一次连续写入（收到其中第一个数据的确认之前）的数据量，我们称为SWND（SendWindow，发送窗口）。

不过，发送端最终以TCP报文段来发送数据，所以SWND限定了发送端能连续发送的TCP报文段数量。这些TCP报文段的最大长度（仅指数据部分）称为SMSS（Sender Maximum Segment Size，发送者最大段大小），其值一般等于MSS。

发送端需要合理地选择SWND的大小。如果SWND太小，会引起明显的网络延迟；反之，如果SWND太大，则容易导致网络拥塞。前文提到，接收方可通过其接收通告窗口（RWND）来控制发送端的SWND。但这显然不够，所以发送端引入了一个称为拥塞窗口（Congestion Window，CWND）的状态变量。实际的SWND值是RWND和CWND中的较小者。  
<img src="./picture/3.7.1.png" width="700"> 

---
### 3.7.1 慢启动和拥塞避免

TCP连接建立好之后，CWND将被设置成初始值IW（InitialWindow），其大小为2～4个SMSS。但新的Linux内核提高了该初始值，以减小传输滞后。此时发送端最多能发送IW字节的数据。此后发送端`每收到接收端的一个确认，其CWND就按下面式子增加`：
```
CWND += min(N, SMSS)
```
其中N是此次确认中包含的之前未被确认的字节数(也就是一次发送的数量)。这样一来，CWND将按照指数形式扩大，这就是所谓的慢启动。慢启动算法的理由是，TCP模块刚开始发送数据时并不知道网络的实际情况，需要用一种试探的方式平滑地增加CWND的大小。  

但是如果不施加其他手段，慢启动必然使得CWND很快膨胀（可见慢启动其实不慢）并最终导致网络拥塞。因此TCP拥塞控制中定义了另一个重要的状态变量：慢启动阈值（slow start threshold size，ssthresh）。当CWND的大小超过该值时，TCP拥塞控制将进入拥塞避免阶段。

拥塞避免算法使得CWND按照线性方式增加，从而减缓其扩大。RFC 5681中提到了如下两种实现方式：

- 每个RTT时间内（而不是每次收到ACK）按上面的式子计算新的CWND，不论该RTT时间内收到多少个ACK。
- 每收到一个对新数据的ACK，就按下式更新CWND。
  ```
  CWND += SMSS * SMSS / CWND
  ```
  **注：** 这个式子可以这样理解，当进入拥塞避免阶段时，假设CWMD = k * SMSS(意思是接收到ACK之前一次能发k条最大的TCP报文)，此时
  SMSS * SMSS / CWND = (1 / k) * SMSS, 也就是说CWND每次增长(1 / k) * SMSS，变成了线性增长。

  <img src="./picture/3.7.1.1.png" width="700"> 

---

以上我们讨论了发送端在未检测到拥塞时所采用的积极避免拥塞的方法。接下来介绍拥塞发生时（可能发生在慢启动阶段或者拥塞避免阶段）拥塞控制的行为。不过我们先要搞清楚发送端是如何判断拥塞已经发生的。发送端判断拥塞发生的依据有如下两个：
1. 传输超时，或者说TCP重传定时器溢出。
2. 接收到重复的确认报文段。

拥塞控制对这两种情况有不同的处理方式。对第一种情况仍然使用慢启动和拥塞避免。对第二种情况则使用快速重传和快速恢复（如果是真的发生拥塞的话）

如果发送端检测到的是第一种情况，则它将进行重传并重新设置ssthresh（慢启动阈值）：
```
ssthresh = max(FlightSize / 2, 2 * SMSS)
```
其中FlightSize是已经发送但未收到确认的字节数。

---
### 3.7.2 快速重传和快速恢复
发送端收到重复的ACK通常发生在以下几种情况：
1. 接收方收到乱序数据
   - 当接收端收到**超出期望序号**的数据包时，它会重传**上一次正确接收的ACK**，即发送重复的ACK。
   - 这通常由网络中的路径变化或分组重新排序导致，而不是数据丢失。
2. 某个数据包丢失
   - 当发送方的某个数据段丢失，但后续数据段成功到达接收方时，接收方会多次发送相同的ACK，以提示发送方该分片丢失。
   - 一般来说，TCP标准使用三次重复ACK（Triple Duplicate ACK）触发快速重传，而不必等待超时（Timeout）。

拥塞控制算法需要判断当收到重复的ACK时，网络是否真的发生了拥塞，或者说TCP报文段是否真的丢失了。具体做法是：发送端如果连续收到3个重复的确认报文段，就认为是拥塞发生了。然后它启用快速重传和快速恢复算法来处理拥塞，过程如下：
1. 当收到第三个重复的ACK时，按照上式计算ssthresh,然后立即重传丢失的报文段，并按照下式设置CWND
   ```
   CWND = ssthresh + 3 * SMSS
   ```
2. 每次收到1个重复的确认时，设置CWND=CWND+SMSS。此时发送端可以发送新的TCP报文段（如果新的CWND允许的话）。
3. 当收到新数据的确认时，设置CWND=ssthresh（ssthresh是新的慢启动门限值，由第一步计算得到）。
<img src="./picture/3.7.2.1.png" width="700"> 

# 4. Linux网络编程基础API

我们将从如下3个方面讨论Linux网络API：

1. socket地址API。socket最开始的含义是一个IP地址和端口对（ip，port）。它唯一地表示了使用TCP通信的一端。本书称其为socket地址。
2. socket基础API。socket的主要API都定义在sys/socket.h头文件中，包括创建socket、命名socket、监听socket、接受连接、发起连接、读写数据、获取地址信息、检测带外标记，以及读取和设置socket选项。
3. 网络信息API。Linux提供了一套网络信息API，以实现主机名和IP地址之间的转换，以及服务名称和端口号之间的转换。这些API都定义在netdb.h头文件中，我们将讨论其中几个主要的函数。


## 4.1 socket地址API

### 4.1.1 主机字节序和网络字节序

现代CPU的累加器一次都能装载（至少）4字节（这里考虑32位机，下同），即一个整数。那么这4字节在内存中排列的顺序将影响它被累加器装载成的整数的值。这就是字节序问题。字节序分为大端字节序（big endian）和小端字节序（little endian）。大端字节序是指一个整数的高位字节（23～31 bit）存储在内存的低地址处，低位字节（0～7 bit）存储在内存的高地址处。小端字节序则是指整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处。

- 大端字节序就是高位存在低地址位
- 小段字节序就是高位存在高地址位

现代PC大多采用小端字节序，因此小端字节序又被称为主机字节序。

当格式化的数据（比如32 bit整型数和16 bit短整型数）在两台使用不同字节序的主机之间直接传递时，接收端必然错误地解释之。解决问题的方法是：发送端总是把要发送的数据转化成大端字节序数据后再发送，而接收端知道对方传送过来的数据总是采用大端字节序，所以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转换（小端机转换，大端机不转换）。因此大端字节序也称为网络字节序，它给所有接收数据的主机提供了一个正确解释收到的格式化数据的保证。

需要指出的是，即使是同一台机器上的两个进程（比如一个由C语言编写，另一个由JAVA编写）通信，也要考虑字节序的问题（JAVA虚拟机采用大端字节序）。

Linux提供了如下4个函数来完成主机字节序和网络字节序之间的转换：

```c
#include<netinet/in.h>
unsigned long int htonl(unsigned long int hostlong);
unsigned short int htons(unsigned short int hostshort);
unsigned long int ntohl(unsigned long int netlong);
unsigned short int ntohs(unsigned short int netshort);
```

这几个函数的命名很明确,`hton`和`ntoh`表示主机到网络（网络到主机），s和l表示使用的是`short`类型还是`long`类型。

### 4.1.2 通用socket地址

socket网络编程接口中表示socket地址的是结构体sockaddr，其定义如下：
```c
#include<bits/socket.h>
struct sockaddr
{
sa_family_t sa_family;
char sa_data[14];
}
```

`sa_family`成员是地址族类型（`sa_family_t`）的变量。地址族类型通常与协议族类型对应。常见的协议族（protocol family，也称domain，见后文）和对应的地址族如下表所示。

|协议族|地址族|描述|
|---------|-----------|------------|
|PF_UNIX|AF_UNIX|UNIX本地域协议族|
|PF_INET|AF_INET|TCP/IPv4协议族|
|PF_INET6|AF_INET6|TCP/IPv6协议族|

宏`PF_*`和`AF_*`都定义在`bits/socket.h`头文件中，且后者与前者有完全相同的值，所以二者通常混用。

`sa_data`成员用于存放`socket`地址值。但是，不同的协议族的地址值具有不同的含义和长度，如下表所示。
|协议族|地址值含义和长度|
|---------|-----------|
|PF_UNIX|文件的路径名，长度可达到108字节|
|PF_INET|16 bit端口号和32 bit IPv4地址，共6字节|
|PF_INET6|16 bit端口号，32 bit流标识，128 bit IPv6地址，32 bit范围ID，共26字节|

由上表可见，14字节的sa_data根本无法完全容纳多数协议族的地址值。因此，Linux定义了下面这个新的通用socket地址结构体：
```c
#include<bits/socket.h>
struct sockaddr_storage
{
sa_family_t sa_family;
unsigned long int__ss_align;
char__ss_padding[128-sizeof(__ss_align)];
}
```

这个结构体不仅提供了足够大的空间用于存放地址值，而且是内存对齐的（这是__ss_align成员的作用）。

### 4.1.3 专用socket地址

UNIX本地域协议族
```c
#include<sys/un.h>
struct sockaddr_un
{
sa_family_t sin_family;/*地址族：AF_UNIX*/
char sun_path[108];/*文件路径名*/
};
```

TCP/IP
```c
struct sockaddr_in
{
sa_family_t sin_family;/*地址族：AF_INET*/
u_int16_t sin_port;/*端口号，要用网络字节序表示*/
struct in_addr sin_addr;/*IPv4地址结构体，见下面*/
};
struct in_addr
{
u_int32_t s_addr;/*IPv4地址，要用网络字节序表示*/
};


struct sockaddr_in6
{
sa_family_t sin6_family;/*地址族：AF_INET6*/
u_int16_t sin6_port;/*端口号，要用网络字节序表示*/
u_int32_t sin6_flowinfo;/*流信息，应设置为0*/
struct in6_addr sin6_addr;/*IPv6地址结构体，见下面*/
u_int32_t sin6_scope_id;/*scope ID，尚处于实验阶段*/
};
struct in6_addr
{
unsigned char sa_addr[16];/*IPv6地址，要用网络字节序表示*/
};
```

所有专用socket地址（以及sockaddr_storage）类型的变量在实际使用时都需要转化为通用socket地址类型sockaddr（强制转换即可），因为所有socket编程接口使用的地址参数的类型都是sockaddr。

### 4.1.4 IP地址转换函数

通常，人们习惯用可读性好的字符串来表示IP地址，比如用点分十进制字符串表示IPv4地址，以及用十六进制字符串表示IPv6地址。但编程中我们需要先把它们转化为整数（二进制数）方能使用。而记录日志时则相反，我们要把整数表示的IP地址转化为可读的字符串。下面3个函数可用于用点分十进制字符串表示的IPv4地址和用网络字节序整数表示的IPv4地址之间的转换：

```c
#include<arpa/inet.h>
in_addr_t inet_addr(const char*strptr);
int inet_aton(const char*cp,struct in_addr*inp);
char* inet_ntoa(struct in_addr in);
```

inet_addr函数将用点分十进制字符串表示的IPv4地址转化为用网络字节序整数表示的IPv4地址。它失败时返回INADDR_NONE。

inet_aton函数完成和inet_addr同样的功能，但是将转化结果存储于参数inp指向的地址结构中。它成功时返回1，失败则返回0。

inet_ntoa函数将用网络字节序整数表示的IPv4地址转化为用点分十进制字符串表示的IPv4地址。但需要注意的是，该函数内部用一个静态变量存储转化结果，函数的返回值指向该静态内存，因此inet_ntoa是不可重入的。

例如下面例子：
```c
int main(){

    struct in_addr addr1, addr2;
    inet_aton("1.2.3.4", &addr1);
    inet_aton("10.194.71.60", &addr2);

    char* szValue1 = inet_ntoa(addr1);
    char* szValue2 = inet_ntoa(addr2);
    
    printf("address 1: %s\n", szValue1);
    printf("address 2: %s\n", szValue2);
    
    return 0;
}
```
输出为：
```
address 1: 10.194.71.60
address 2: 10.194.71.60
```

下面这对更新的函数也能完成和前面3个函数同样的功能，并且它们同时适用于IPv4地址和IPv6地址：
```c
#include<arpa/inet.h>
int inet_pton(int af,const char*src,void*dst);
const char*inet_ntop(int af,const void*src,char*dst,socklen_t cnt);
```
inet_pton函数将用字符串表示的IP地址src（用点分十进制字符串表示的IPv4地址或用十六进制字符串表示的IPv6地址）转换成用网络字节序整数表示的IP地址，并把转换结果存储于dst指向的内存中。其中，af参数指定地址族，可以是AF_INET或者AF_INET6。inet_pton成功时返回1，失败则返回0并设置error.

inet_ntop函数进行相反的转换，前三个参数的含义与inet_pton的参数相同，最后一个参数cnt指定目标存储单元的大小。下面的两个宏能帮助我们指定这个大小（分别用于IPv4和IPv6）：
```c
#include<netinet/in.h>
#define INET_ADDRSTRLEN 16
#define INET6_ADDRSTRLEN 46
```

### 4.1.5 errno
在`socket`编程中，`errno`是一个全局变量（在多线程环境下通常使用`pthread_errno`或`errno`线程局部变量），用于存储最近一次系统调用失败时的错误码。它主要用于错误处理，帮助开发者分析`socket`相关的错误。  
在 socket 编程中，当某些系统调用失败时，通常返回 -1，同时 errno 会被设置为具体的错误代码。


## 4.2 创建socket

UNIX/Linux的一个哲学是：所有东西都是文件。socket也不例外，它就是可读、可写、可控制、可关闭的文件描述符(`fd`)。下面的socket系统调用可创建一个socket：
```
#include<sys/types.h>
#include<sys/socket.h>
int socket(int domain, int type, int protocol);
```
domain参数告诉系统使用哪个底层协议族。对TCP/IP协议族而言，该参数应该设置为PF_INET（Protocol Family of Internet，用于IPv4）或PF_INET6（用于IPv6）；对于UNIX本地域协议族而言，该参数应该设置为PF_UNIX。关于socket系统调用支持的所有协议族，请读者自己参考其man手册。  

type参数指定服务类型。服务类型主要有`SOCK_STREAM`服务（流服务）和`SOCK_UGRAM`（数据报）服务。对TCP/IP协议族而言，其值取SOCK_STREAM表示传输层使用TCP协议，取SOCK_DGRAM表示传输层使用UDP协议。  

值得指出的是，自Linux内核版本2.6.17起，type参数可以接受上述服务类型与下面两个重要的标志相与的值(&)：`SOCK_NONBLOCK`和`SOCK_CLOEXEC`。它们分别表示将新创建的socket设为非阻塞的，以及用fork调用创建子进程时在子进程中关闭该socket。在内核版本2.6.17之前的Linux中，文件描述符的这两个属性都需要使用额外的系统调用（比如fcntl）来设置。  

protocol参数是在前两个参数构成的协议集合下，再选择一个具体的协议。不过这个值通常都是唯一的（前两个参数已经完全决定了它的值）。几乎在所有情况下，我们都应该把它设置为0，表示使用默认协议。  

socket系统调用成功时返回一个socket文件描述符(`sockfd`)，失败则返回-1并设置errno。

## 4.3 命名socket

创建socket时，我们给它指定了地址族，但是并未指定使用该地址族中的哪个具体socket地址。将一个socket与socket地址绑定称为给socket命名。
在服务器程序中，我们通常要命名socket，因为只有命名后客户端才能知道该如何连接它。客户端则通常不需要命名socket，而是采用匿名方式，即使用操作系统自动分配的socket地址。命名socket的系统调用是bind，其定义如下：
```c
#include<sys/types.h>
#include<sys/socket.h>
int bind(int sockfd, const struct sockaddr* my_addr, socklen_t addrlen);
```

bind将my_addr所指的socket地址分配给未命名的sockfd文件描述符，addrlen参数指出该socket地址的长度。

bind成功时返回0，失败则返回-1并设置errno。其中两种常见的errno是EACCES和EADDRINUSE，它们的含义分别是：

- EACCES，被绑定的地址是受保护的地址，仅超级用户能够访问。比如普通用户将socket绑定到知名服务端口（端口号为0～1023）上时，bind将返回EACCES错误。
- EADDRINUSE，被绑定的地址正在使用中。比如将socket绑定到一个处于TIME_WAIT状态的socket地址。

## 4.4 监听socket
socket被命名之后，还不能马上接受客户连接，我们需要使用如下系统调用来创建一个监听队列以存放待处理的客户连接：
```c
#include<sys/socket.h>
int listen(int sockfd, int backlog);
```
sockfd参数指定被监听的socket。backlog参数提示内核监听队列的最大长度。监听队列的长度如果超过backlog，服务器将不受理新的客户连接，客户端也将收到ECONNREFUSED错误信息。在内核版本2.2之前的Linux中，backlog参数是指所有处于半连接状态（SYN_RCVD）和完全连接状态（ESTABLISHED）的socket的上限。但自内核版本2.2之后，它只表示处于完全连接状态的socket的上限，处于半连接状态的socket的上限则由/proc/sys/net/ipv4/tcp_max_syn_backlog内核参数定义。backlog参数的典型值是5。  
listen成功时返回0，失败则返回-1并设置errno。  

## 4.5 接受连接
下面的系统调用从listen监听队列中接受一个连接：
```c
#include<sys/types.h>
#include<sys/socket.h>
int accept(int sockfd,struct sockaddr*addr,socklen_t*addrlen);
```

- sockfd参数是执行过listen系统调用的监听socket.
- addr参数用来接收连接的远程socket地址。
- 该socket地址的长度由addrlen指出。

accept成功时返回一个新的连接socket，该socket唯一地标识了被接受的这个连接，服务器可通过读写该socket来与被接受连接对应的客户端通信。accept失败时返回-1并设置errno。

现在考虑如下情况：如果监听队列中处于ESTABLISHED状态的连接对应的客户端出现网络异常（比如掉线），或者提前退出，那么服务器对这个连接执行的accept调用是否成功？

accept只是从监听队列中取出连接，而不论连接处于何种状态（如上面的ESTABLISHED状态和CLOSE_WAIT状态），更不关心任何网络状况的变化。

## 4.6 TCP半连接队列和全连接队列

在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：

- 半连接队列，也称SYN队列。
- 全连接队列，也称accept队列。

服务端收到客户端发送的SYN请求后，**内核会把该链接储存到半连接队列**，并向客户端响应SYN + ACK,接着客户端会返回ACK,服务端收到三次握手的ACK后，**内核会把连接从半连接队列移除，然后创建新的完全连接，并将其添加到accept队列，等待进程调用accept函数时把连接取出来。
  <img src="./picture/4.6.1.png" width="700"> 

## 4.7 发起连接
如果说服务器通过listen调用来被动接受连接，那么客户端需要通过如下系统调用来主动与服务器建立连接：
```c
#include<sys/types.h>
#include<sys/socket.h>
int connect(int sockfd,const struct sockaddr*serv_addr,socklen_t addrlen);
```
sockfd参数由socket系统调用返回一个socket。serv_addr参数是服务器监听的socket地址，addrlen参数则指定这个地址的长度。

connect成功时返回0。一旦成功建立连接，sockfd就唯一地标识了这个连接，客户端就可以通过读写sockfd来与服务器通信。connect失败则返回-1并设置errno。其中两种常见的errno是ECONNREFUSED和ETIMEDOUT，它们的含义如下：

- ECONNREFUSED，目标端口不存在，连接被拒绝。
- ETIMEDOUT，连接超时。

## 4.8 关闭连接
关闭一个连接实际上就是关闭该连接对应的socket，这可以通过如下关闭普通文件描述符的系统调用来完成：
```c
#include<unistd.h>
int close(int fd)
```
fd参数是待关闭的socket。不过，close系统调用并非总是立即关闭一个连接，而是将fd的引用计数减1。只有当fd的引用计数为0时，才真正关闭连接。多进程程序中，一次fork系统调用默认将使父进程中打开的socket的引用计数加1，因此我们必须在父进程和子进程中都对该socket执行close调用才能将连接关闭。

如果无论如何都要立即终止连接（而不是将socket的引用计数减1），可以使用如下的shutdown系统调用（相对于close来说，它是专门为网络编程设计的）：
```c
#include<sys.socket.h>
int shutdown(int sockfd, int howto);
```
sockfd参数是待关闭的socket。howto参数决定了shutdown的行为:
- `SHUT_RD` 关闭sockfd上读的这一半，应用程序不能再针对socket文件描述符执行读操作，并且该socket接收缓冲区中的数据全部被丢弃。
- `SHUT_RW` 关闭sockfd上写的这一半，sockfd的发送缓冲区会在程序真正关闭连接的时候全部发送出去。这种情况下，连接处于半关闭状态（[3.3.2 半关闭状态](#332-半关闭状态)）。
- `SHUT_RDWR` 同时关闭sockfd上的读和写。

由此可见，shutdown能够分别关闭socket上的读或写，或者都关闭。而close在关闭连接时只能将socket上的读和写同时关闭。  
shutdown成功时返回0，失败则返回-1并设置errno。

## 4.9 数据读写

### 4.9.1 TCP数据读写（`recv`和`send`）

对文件的读写操作read和write同样适用于socket。但是socket编程接口提供了几个专门用于socket数据读写的系统调用，它们增加了对数据读写的控制。其中用于TCP流数据读写的系统调用是：
```c
#include<sys/types.h>
#include<sys/socket.h>
ssize_t recv(int sockfd,void*buf,size_t len,int flags);
ssize_t send(int sockfd,const void*buf,size_t len,int flags);
```

recv读取sockfd上的数据，buf和len参数分别指定读缓冲区的位置和大小，flags参数的含义见后文，通常设置为0即可。recv成功时返回实际读取到的数据的长度，它可能小于我们期望的长度len。因此我们可能要多次调用recv，才能读取到完整的数据。recv可能返回0，这意味着通信对方已经关闭连接了。recv出错时返回-1并设置errno。  

send往sockfd上写入数据，buf和len参数分别指定写缓冲区的位置和大小。send成功时返回实际写入的数据的长度，失败则返回-1并设置errno。

flags参数为数据收发提供了额外的控制，它可以取下表所示选项中的一个或几个的逻辑或。

<img src="./picture/4.9.1.1.png" width="700"> 

socket默认情况下是阻塞模式。

在`recv`中，阻塞和非阻塞的具体差异表现在该socket在内核中的接收缓冲区为空时，是否会立刻返回。阻塞会阻塞当前线程等待接收缓冲区中有数据，而非阻塞会立刻返回。

`recv`通过系统调用recvfrom进入内核态，把接收缓冲区地数据拷贝到`buf`中。  
返回值有三种可能：
1. 正数：成功接收到数据，返回接收到的字节数。
2. 0：对端的正常关闭连接（发送了FIN包）。
3. 负数：发生错误，在全局变量中包含具体错误类型
   - 可接受错误：
     - EAGAIN或EWOULDBLOCK：表示**非阻塞模式下**，当前接受缓冲区中无数据可读。处理方式：等待下次可读事件，无需关闭连接。
     - EINTR：表示系统调用被信号（如SIGINT）中断。处理方式：重新调用`recv`,无需断开连接。
   - 不可接受错误：其他错误，需要关闭资源。

### 4.9.2 UDP数据读写

socket编程接口中用于UDP数据报读写的系统调用是：
```c
#include <sys/types.h>
#include <sys/socket.h>
ssize_t recvfrom(int sockfd,void*buf,size_t len,int flags,struct sockaddr*src_addr,socklen_t*addrlen);
ssize_t sendto(int sockfd,const void*buf,size_t len,int flags,const struct sockaddr*dest_addr,socklen_t addrlen);
```

recvfrom读取sockfd上的数据，buf和len参数分别指定读缓冲区的位置和大小。因为UDP通信没有连接的概念，所以我们每次读取数据都需要获取发送端的socket地址，即参数src_addr所指的内容，addrlen参数则指定该地址的长度。

sendto往sockfd上写入数据，buf和len参数分别指定写缓冲区的位置和大小。dest_addr参数指定接收端的socket地址，addrlen参数则指定该地址的长度。

值得一提的是，recvfrom/sendto系统调用也可以用于面向连接（STREAM）的socket的数据读写，只需要把最后两个参数都设置为NULL以忽略发送端/接收端的socket地址（因为我们已经和对方建立了连接，所以已经知道其socket地址了）。

### 4.9.3 通用数据读写函数

socket编程接口还提供了一对通用的数据读写系统调用。它们不仅能用于TCP流数据，也能用于UDP数据报：

```c
#include<sys/socket.h>
ssize_t recvmsg(int sockfd,struct msghdr*msg,int flags);
ssize_t sendmsg(int sockfd,struct msghdr*msg,int flags);
```
sockfd参数指定被操作的目标socket。msg参数是msghdr结构体类型的指针，msghdr结构体的定义如下：
```c
struct msghdr
{
void*msg_name;/*socket地址*/
socklen_t msg_namelen;/*socket地址的长度*/
struct iovec*msg_iov;/*分散的内存块，见后文*/
int msg_iovlen;/*分散内存块的数量*/
void*msg_control;/*指向辅助数据的起始位置*/
socklen_t msg_controllen;/*辅助数据的大小*/
int msg_flags;/*复制函数中的flags参数，并在调用过程中更新*/
};
```
msg_name成员指向一个socket地址结构变量。它指定通信对方的socket地址。对于面向连接的TCP协议，该成员没有意义，必须被设置为NULL。这是因为对数据流socket而言，对方的地址已经知道。msg_namelen成员则指定了msg_name所指socket地址的长度。  

msg_iov成员是iovec结构体类型的指针，iovec结构体的定义如下：
```c
struct iovec
{
void*iov_base;/*内存起始地址*/
size_t iov_len;/*这块内存的长度*/
};
```

由上可见，iovec结构体封装了一块内存的起始位置和长度。msg_iovlen指定这样的iovec结构对象有多少个。对于recvmsg而言，数据将被读取并存放在msg_iovlen块分散的内存中，这些内存的位置和长度则由msg_iov指向的数组指定，这称为分散读（scatter read）；对于
sendmsg而言，msg_iovlen块分散内存中的数据将被一并发送，这称为集中写（gather write）。

msg_control和msg_controllen成员用于辅助数据的传送。我们不详
细讨论它们，仅在第13章介绍如何使用它们来实现在进程间传递文件
描述符。

msg_flags成员无须设定，它会复制recvmsg/sendmsg的flags参数的
内容以影响数据读写过程。recvmsg还会在调用结束前，将某些更新后
的标志设置到msg_flags中。

recvmsg/sendmsg的flags参数以及返回值的含义均与send/recv的flags
参数及返回值相同。

## 4.10 地址信息函数

在某些情况下，我们想知道一个连接socket的本端socket地址，以及远端的socket地址。下面这两个函数正是用于解决这个问题：
```c
#include <sys/socket.h>
int getsockname(int sockfd,struct sockaddr*address,socklen_t*address_len);
int getpeername(int sockfd,struct sockaddr*address,socklen_t*address_len);
```

getsockname获取sockfd对应的本端socket地址，并将其存储于address参数指定的内存中，该socket地址的长度则存储于address_len参数指向的变量中。如果实际socket地址的长度大于address所指内存区的大小，那么该socket地址将被截断。getsockname成功时返回0，失败返回-1并设置errno。  

getpeername获取sockfd对应的远端socket地址，其参数及返回值的含义与getsockname的参数及返回值相同。

## 4.11 socket选项

如果说fcntl系统调用是控制文件描述符属性的通用POSIX方法，那么下面两个系统调用则是专门用来读取和设置socket文件描述符属性的方法：
```c
#include<sys/socket.h>
int getsockopt(int sockfd,int level,int option_name,void*option_value,socklen_t* restrict option_len);
int setsockopt(int sockfd,int level,int option_name,const void*option_value,socklen_t option_len);
```

sockfd参数指定被操作的目标socket。level参数指定要操作哪个协议的选项（即属性），比如IPv4、IPv6、TCP等。option_name参数则指定选项的名字。我们在表5-5中列举了socket通信中几个比较常用的socket选项。option_value和option_len参数分别是被操作选项的值和长度。不同的选项具有不同类型的值，如表5-5中“数据类型”一列所示。

<img src="./picture/4.11.1.png" width="700"> 

getsockopt和setsockopt这两个函数成功时返回0，失败时返回-1并设置errno。

值得指出的是，对服务器而言，有部分socket选项只能在调用listen系统调用前针对监听socket设置才有效。这是因为连接socket只能由accept调用返回，而accept从listen监听队列中接受的连接至少已经完成了TCP三次握手的前两个步骤（因为listen监听队列中的连接至少已进入SYN_RCVD状态），这说明服务器已经往被接受连接上发送出了TCP同步报文段。但有的socket选项却应该在TCP同步报文段中设置，比如TCP最大报文段选项（回忆3.2.2小节，该选项只能由同步报文段来发送）。对这种情况，Linux给开发人员提供的解决方案是：对监听socket设置这些socket选项，那么accept返回的连接socket将自动继承这些选项。

这些socket选项包括：SO_DEBUG、SO_DONTROUTE、SO_KEEPALIVE、SO_LINGER、SO_OOBINLINE、SO_RCVBUF、SO_RCVLOWAT、SO_SNDBUF、SO_SNDLOWAT、TCP_MAXSEG和TCP_NODELAY。

而对客户端而言，这些socket选项则应该在调用connect函数之前设置，因为connect调用成功返回之后，TCP三次握手已完成。

## 4.12 网络信息API

socket地址的两个要素，即IP地址和端口号，都是用数值表示的。这不便于记忆，也不便于扩展（比如从IPv4转移到IPv6）。因此在前面的章节中，我们用主机名来访问一台机器，而避免直接使用其IP地址。同样，我们用服务名称来代替端口号。比如，下面两条telnet命令具有完全相同的作用：
```
telnet 127.0.0.1 80
telnet localhost www
```
上面的例子中，telnet客户端程序是通过调用某些网络信息API来实现主机名到IP地址的转换，以及服务名称到端口号的转换的。下面我们将讨论网络信息API中比较重要的几个。

## 4.12.1 gethostbyname和gethostbyaddr
gethostbyname函数根据主机名称获取主机的完整信息，gethostbyaddr函数根据IP地址获取主机的完整信息。gethostbyname函数通常先在本地的/etc/hosts配置文件中查找主机，如果没有找到，再去访问DNS服务器。这些在前面章节中都讨论过。这两个函数的定义如下：

```c
#include <netdb.h>
struct hostent* gethostbyname(const char*name);
struct hostent* gethostbyaddr(const void*addr,size_t len,int type);
```

name参数指定目标主机的主机名，addr参数指定目标主机的IP地址，len参数指定addr所指IP地址的长度，type参数指定addr所指IP地址的类型，其合法取值包括AF_INET（用于IPv4地址）和AF_INET6（用于IPv6地址）。

这两个函数返回的都是hostent结构体类型的指针，hostent结构体的定义如下：
```c
#include <netdb.h>
struct hostent
{
char*h_name;/*主机名*/
char**h_aliases;/*主机别名列表，可能有多个*/
int h_addrtype;/*地址类型（地址族）*/
int h_length;/*地址长度*/
char**h_addr_list/*按网络字节序列出的主机IP地址列表*/
};
```

## 4.12.2 getservbyname和getservbyport

getservbyname函数根据名称获取某个服务的完整信息，getservbyport函数根据端口号获取某个服务的完整信息。它们实际上都是通过读取/etc/services文件来获取服务的信息的。这两个函数的定义如下：
```c
struct servent* getservbyname(const char*name,const char*proto);
struct servent* getservbyport(int port,const char*proto);
```
name参数指定目标服务的名字，port参数指定目标服务对应的端口号。proto参数指定服务类型，给它传递“tcp”表示获取流服务，给它传递“udp”表示获取数据报服务，给它传递NULL则表示获取所有类型的服务。

这两个函数返回的都是servent结构体类型的指针，结构体servent的定义如下：
```c
#include <netdb.h>
struct servent
{
char*s_name;/*服务名称*/
char**s_aliases;/*服务的别名列表，可能有多个*/
int s_port;/*端口号*/
char*s_proto;/*服务类型,通常是tcp或者udp*/
};

```

# 文件描述符的引用计数
在Linux或类Unix操作系统中，文件描述符的引用计数（Reference Count of File Descriptor）用于跟踪一个打开文件在系统中的引用次数，以确保文件资源在不再使用时被正确释放。

**文件描述符与`struct file`**  
   在内核中，每个打开的文件都会对应一个struct file结构，而进程使用文件描述符（File Descriptor, FD）来访问这个结构。例如：
   ```c
   struct file {
    atomic_long_t f_count;  // 引用计数
    struct inode *f_inode;
    struct file_operations *f_op;
    ...
    };
   ```
   - f_count 是 struct file 的引用计数，表示该 struct file 结构被多少个文件描述符或进程引用。
   - 当 f_count 变为 0 时，内核会释放该 struct file，关闭文件并释放资源。

# 5. 高级I/O函数

Linux提供了很多高级的I/O函数。它们并不像Linux基础I/O函数（比如open和read）那么常用（编写内核模块时一般要实现这些I/O函数），但在特定的条件下却表现出优秀的性能。本章将讨论其中和网络编程相关的几个，这些函数大致分为三类：

- 用于创建文件描述符的函数，包括pipe、dup/dup2函数。
- 用于读写数据的函数，包括readv/writev、sendfile、mmap/munmap、splice和tee函数。
- 用于控制I/O行为和属性的函数，包括fcntl函数。

## 5.1 pipe函数
pipe函数可用于创建一个管道，以实现进程间通信。我们将在13.4节讨论如何使用管道来实现进程间通信，本章只介绍其基本使用方式。pipe函数的定义如下：
```c
#include <unistd.h>
int pipe(int fd[2]);
```
pipe函数的参数是一个包含两个int型整数的数组指针。该函数成功时返回0，并将一对打开的文件描述符值填入其参数指向的数组。如果失败，则返回-1并设置errno。
- `pipefd[0]`：管道的读端（用于读取数据）。
- `pipefd[1]`：管道的写端（用于写入数据）。

管道特性:
- 单向通信：数据只能从 pipefd[1]（写端）流向 pipefd[0]（读端）。
- 有缓存：内核提供一个 固定大小（通常 4KB 或 64KB） 的缓存区，用于存储写入的数据。
- 阻塞行为：
    - 读端阻塞：当管道为空，read() 会阻塞，直到写端有数据或关闭。
    - 写端阻塞：当管道满了，write() 会阻塞，直到读端读取数据或关闭。  

如果要实现双向的数据传输，就应该使用两个管道。默认情况下，这一对文件描述符都是阻塞的。

如果管道的写端文件描述符fd[1]的引用计数减少至0，即没有任何进程需要往管道中写入数据，则针对该管道的读端文件描述符fd[0]的read操作将返回0，即读取到了文件结束标记（End Of File，EOF）；  
反之，如果管道的读端文件描述符fd[0]的引用计数减少至0，即没有任何进程需要从管道读取数据，则针对该管道的写端文件描述符fd[1]的write操作将失败，并引发SIGPIPE信号。

管道内部传输的数据是字节流，这和TCP字节流的概念相同。但二者又有细微的区别。应用层程序能往一个TCP连接中写入多少字节的数据，取决于对方的接收通告窗口的大小和本端的拥塞窗口的大小。而管道本身拥有一个容量限制，它规定如果应用程序不将数据从管道读走的话，该管道最多能被写入多少字节的数据。自Linux 2.6.11内核起，管道容量的大小默认是65536字节。我们可以使用fcntl函数来修改管道容量.

此外，socket的基础API中有一个socketpair函数。它能够方便地创建双向管道。其定义如下：
```c
#include <sys/types.h>
#include <sys/socket.h>
int socketpair(int domain, int type, int prorocol, int fd[2]);
```

socketpair前三个参数的含义与socket系统调用的三个参数完全相同，但domain只能使用UNIX本地域协议族AF_UNIX，因为我们仅能在本地使用这个双向管道。最后一个参数则和pipe系统调用的参数一样，只不过socketpair创建的这对文件描述符都是既可读又可写的。socketpair成功时返回0，失败时返回-1并设置errno。

## 5.2 dup函数和dup2函数

有时我们希望把标准输入重定向到一个文件，或者把标准输出重定向到一个网络连接（比如CGI编程）。这可以通过下面的用于复制文件描述符的dup或dup2函数来实现：

```c
#include<unistd.h>
int dup(int file_descriptor);
int dup2(int file_descriptor_one,int file_descriptor_two);
```

dup函数创建一个新的文件描述符，该新文件描述符和原有文件描述符file_descriptor指向相同的文件、管道或者网络连接。并且dup返回的文件描述符总是取系统`当前可用的最小整数值`。dup2和dup类似，不过它将返回第一个不小于file_descriptor_two的整数值。dup和dup2系统调用失败时返回-1并设置errno。  

注意 通过dup和dup2创建的文件描述符并不继承原文件描述符的属性，比如close-on-exec和non-blocking等。

`due()`主要用于标准输入/输出重定向，文件共享等。
比如：
```
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>

int main() {
    int fd = open("test.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd == -1) {
        perror("open");
        return 1;
    }

    int fd_copy = dup(fd);
    if (fd_copy == -1) {
        perror("dup");
        return 1;
    }

    write(fd, "Hello ", 6);
    write(fd_copy, "World!", 6);

    close(fd);
    close(fd_copy);
    return 0;
}
```
最终test.txt中的内容为“Hello world!”。`fd`和`fd_copy`指向同一个文件，写入数据时不会覆盖，而是追加到同一位置。  
由于dup总是使用最小整数值，我们可以直接关闭标准输出文件描述符`STDOUT_FILENO`（其值是1），然后复制socket文件描述符connfd，这样一来服务器输出到标准输出的内容就会直接发送到与客户端连接对应的socket上，因此printf调用的输出将被客户端获得（而不是显示在服务器程序的终端上）。这就是CGI服务器的工作原理(Common Gateway Interface 服务器)。  
简易的CGI服务器：
```c
#include<sys/socket.h>
#include<netinet/in.h>
#include<arpa/inet.h>
#include<assert.h>
#include<stdio.h>
#include<unistd.h>
#include<stdlib.h>
#include<errno.h>
#include<string.h>
int main(int argc,char*argv[])
{
if(argc<=2)
{
printf("usage:%s ip_address port_number\n",basename(argv[0]));
return 1;
}
const char*ip=argv[1];
int port=atoi(argv[2]);
struct sockaddr_in address;
bzero(＆address,sizeof(address));
address.sin_family=AF_INET;
inet_pton(AF_INET,ip,＆address.sin_addr);
address.sin_port=htons(port);
int sock=socket(PF_INET,SOCK_STREAM,0);
assert(sock>=0);
int ret=bind(sock,(struct sockaddr*)＆address,sizeof(address));
assert(ret!=-1);
ret=listen(sock,5);
assert(ret!=-1);
struct sockaddr_in client;
socklen_t client_addrlength=sizeof(client);
int connfd=accept(sock,(struct sockaddr*)＆client,＆client_addrlength);
if(connfd<0)
{
printf("errno is:%d\n",errno);
}
else
{
close(STDOUT_FILENO);
dup(connfd);
printf("abcd\n");
close(connfd);
}
close(sock);
return 0;
}
```

如果要指定新的文件描述符值，可以使用`dup2()`:
```c
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>

int main() {
    int fd = open("output.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd == -1) {
        perror("open");
        return 1;
    }

    dup2(fd, STDOUT_FILENO);  // 重定向 stdout 到 fd
    close(fd);

    printf("这句话会写入 output.txt\n");
    return 0;
}

```
`dup2(fd, STDOUT_FILENO)` 重定向 `stdout` 到 `fd`，所以 `printf()` 输出到文件而不是终端。

## 5.3 readv函数和writev函数
readv函数将数据从文件描述符读到分散的内存块中，即分散读；writev函数则将多块分散的内存数据一并写入文件描述符中，即集中写。它们的定义如下：
```
#include <sys/uio.h>
ssize_t readv(int fd,const struct iovec*vector,int count)；
ssize_t writev(int fd,const struct iovec*vector,int count);
```
fd参数是被操作的目标文件描述符。vector参数的类型是iovec结构数组。该结构体描述一块内存区。count参数是vector数组的长度，即有多少块内存数据需要从fd读出或写到fd。readv和writev在成功时返回读出/写入fd的字节数，失败则返回-1并设置errno。它们相当于简化版的recvmsg和sendmsg函数。([4.9.3 通用数据读写函数](#493-通用数据读写函数)).  

当Web服务器解析完一个HTTP请求之后，如果目标文档存在且客户具有读取该文档的权限，那么它就需要发送一个HTTP应答来传输该文档。这个HTTP应答包含1个状态行、多个头部字段、1个空行和文档的内容。其中，前3部分的内容可能被Web服务器放置在一块内存中，而文档的内容则通常被读入到另外一块单独的内存中（通过read函数或mmap函数）。我们并不需要把这两部分内容拼接到一起再发送，而是可以使用writev函数将它们同时写出.

在使用 writev() 进行集中写(scatter-gather I/O)时，接收方（浏览器或 HTTP 客户端）并不会直接知道数据是由多个内存块拼接后发送的，而是会根据 HTTP 协议格式 来解析收到的数据。接收方的解析流程如下：

1. writev() 发送的数据格式
假设 Web 服务器使用 writev() 发送 HTTP 响应，其中：  
    - 状态行、头部字段、空行 放在 第一块内存（块1）。
    - HTML/文件内容 放在 第二块内存（块2）。  
示例：
```c
struct iovec iov[2];
iov[0].iov_base = "HTTP/1.1 200 OK\r\nContent-Length: 14\r\n\r\n";
iov[0].iov_len  = 34;
iov[1].iov_base = "Hello, World!\n";
iov[1].iov_len  = 14;
writev(socket_fd, iov, 2);
```

最终发送的 TCP 数据
```css
HTTP/1.1 200 OK\r\n
Content-Length: 14\r\n
\r\n
Hello, World!\n
```

2. 接收方如何解析数据
即使 writev() 发送的是分散的多个数据块，接收方接收到的是 一个完整的 TCP 流，HTTP 解析器会按以下方式解析：

(1) 解析状态行
读取第一行：
```
HTTP/1.1 200 OK\r\n
```
识别 `HTTP/1.1` 版本，`200 OK` 状态码。

(2) 解析 HTTP 头部  
继续按行读取：
```css
Content-Length: 14\r\n
```
识别 `Content-Length` 头，得知正文长度为 14 字节。

(3) 识别空行
遇到：
```
\r\n
```
空行表示头部结束，正文开始。

(4) 解析正文
根据 Content-Length: 14，接收接下来的 14 字节：
```
Hello, World!\n
```
关键点：TCP 是流式协议，数据块无边界  
TCP 不关心 writev() 是否使用多个缓冲区，它只会保证字节流的顺序不变。  
HTTP 协议解析器 依赖 换行符（\r\n）和 Content-Length 来拆分数据，而不是 TCP 数据块的边界。  
浏览器（或 HTTP 客户端）按照 HTTP 头格式 解析数据后，会提取正文并显示。

## 5.4 sendfile函数

sendfile函数在两个文件描述符之间直接传递数据（完全在内核中操作），从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，效率很高，这被称为零拷贝。sendfile函数的定义如下：

```c
#include<sys/sendfile.h>
ssize_t sendfile(int out_fd,int in_fd,off_t*offset,size_t count);
```

in_fd参数是待读出内容的文件描述符，out_fd参数是待写入内容的文件描述符。offset参数指定从读入文件流的哪个位置开始读，如果为空，则使用读入文件流默认的起始位置。count参数指定在文件描述符in_fd和out_fd之间传输的字节数。sendfile成功时返回传输的字节数，失败则返回-1并设置errno。  
该函数的man手册明确指出，`in_fd必须是一个支持类似mmap函数的文件描述符，即它必须指向真实的文件，不能是socket和管道；而out_fd则必须是一个socket。`

## 5.5 mmap函数和munmap函数

mmap函数用于申请一段内存空间。我们可以将这段内存作为进程间通信的共享内存，也可以将文件直接映射到其中。munmap函数则释放由mmap创建的这段内存空间。它们的定义如下：
```c
#include<sys/mman.h>
void*mmap(void*start,size_t length,int prot,int flags,int fd,off_t offset);
int munmap(void*start,size_t length);
```
start参数允许用户使用某个特定的地址作为这段内存的起始地址。如果它被设置成NULL，则系统自动分配一个地址。length参数指定内存段的长度。prot参数用来设置内存段的访问权限。它可以取以下几个值的按位或：  
- PROT_READ，内存段可读。
- PROT_WRITE，内存段可写。
- PROT_EXEC，内存段可执行。
- PROT_NONE，内存段不能被访问。

flags参数控制内存段内容被修改后程序的行为。它可以被设置为表6-1中的某些值（这里仅列出了常用的值）的按位或（其中MAP_SHARED和MAP_PRIVATE是互斥的，不能同时指定）。

<img src="./picture/6.5.1.png" width="700"> 

fd参数是被映射文件对应的文件描述符。它一般通过open系统调用获得。offset参数设置从文件的何处开始映射（对于不需要读入整个文件的情况）。

mmap函数成功时返回指向目标内存区域的指针，失败则返回MAP_FAILED（(void*)-1）并设置errno。munmap函数成功时返回0，失败则返回-1并设置errno。

## 5.6 splice函数

## 5.7 tree函数

## 5.8 fcntl函数

# 6. Linux服务器程序规范

# 9. IO复用

I/O复用使得程序能同时监听多个文件描述符，这对提高程序的性能至关重要。通常，网络程序在下列情况下需要使用I/O复用技术：

- 客户端要同时处理多个socket。
- 客户端要同时处理用户输入和网络连接。
- TCP服务器要同时处理监听socket和连接socket。
- 服务器要同时处理TCP请求和UDP请求。
- 服务器要同时监听多个端口。

需要指出的是，I/O复用虽然能同时监听多个文件描述符，但它本身是阻塞的。并且当多个文件描述符同时就绪时，如果不采取额外的措施，程序就只能按顺序依次处理其中的每一个文件描述符，这使得服务器程序看起来像是串行工作的。如果要实现并发，只能使用多进程或多线程等编程手段。

## 9.1 select系统调用

select系统调用的用途是：在一段指定时间内，监听用户感兴趣的文件描述符上的可读、可写和异常等事件。

### 9.1.1 select API
```c
#include<sys/select.h>
int select(int nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout);
```
1. `nfds`参数指定被监听的文件描述符的总数。它通常被设置为select监听的所有文件描述符中的最大值加1，因为文件描述符是从0开始计数的。
2. `readfds`、`writefds`和`exceptfds`参数分别指向可读、可写和异常等事件对应的文件描述符集合。应用程序调用select函数时，通过这3个参数传入自己感兴趣的文件描述符。select调用返回时，内核将修改它们来通知应用程序哪些文件描述符已经就绪。这3个参数是fd_set结构指针类型。fd_set结构体的定义如下：
```c
#include<typesizes.h>
#define __FD_SETSIZE 1024
#include<sys/select.h>
#define FD_SETSIZE__FD_SETSIZE
typedef long int__fd_mask;
#undef __NFDBITS
#define __NFDBITS(8*(int)sizeof(__fd_mask))
typedef struct
{
#ifdef __USE_XOPEN
__fd_mask fds_bits[__FD_SETSIZE/__NFDBITS];
#define __FDS_BITS(set)((set)-＞fds_bits)
#else
__fd_mask__fds_bits[__FD_SETSIZE/__NFDBITS];
#define __FDS_BITS(set)((set)-＞__fds_bits)
#endif
}fd_set;
```

`fd_set` 是一个 位掩码（bitmask），用于存储多个文件描述符的状态。在 select() 调用时，可以监视多个 socket 的 读、写和异常 事件。

由以上定义可见，fd_set结构体仅包含一个整型数组，该数组的每个元素的每一位（bit）标记一个文件描述符。fd_set能容纳的文件描述符数量由FD_SETSIZE指定，这就限制了select能同时处理的文件描述符的总量。

由于位操作过于烦琐，我们应该使用下面的一系列宏来访问fd_set结构体中的位：

```c
FD_ZERO(fd_set*fdset);/*清除fdset的所有位*/
FD_SET(int fd,fd_set*fdset);/*设置fdset的位fd*/
FD_CLR(int fd,fd_set*fdset);/*清除fdset的位fd*/
int FD_ISSET(int fd,fd_set*fdset);/*测试fdset的位fd是否就绪（可读，可写，异常）（返回非零值）*/
```

3. timeout参数用来设置select函数的超时时间。它是一个timeval结构类型的指针，采用指针参数是因为内核将修改它以告诉应用程序select等待了多久。不过我们不能完全信任select调用返回后的timeout值，比如调用失败时timeout值是不确定的。timeval结构体的定义如下：
```c
struct timeval
{
long tv_sec;/*秒数*/
long tv_usec;/*微秒数*/
};
```

由以上定义可见，select给我们提供了一个微秒级的定时方式。如果给timeout变量的tv_sec成员和tv_usec成员都传递0，则select将立即返回。如果给timeout传递NULL，则select将一直阻塞，直到某个文件描述符就绪。

select成功时返回就绪（可读、可写和异常）文件描述符的总数。如果在超时时间内没有任何文件描述符就绪，select将返回0。select失败时返回-1并设置errno。如果在select等待期间，程序接收到信号，则select立即返回-1，并设置errno为EINTR。

### 9.1.2 文件描述符就绪条件

哪些情况下文件描述符可以被认为是可读、可写或者出现异常，对于select的使用非常关键。 

低水位标记（如`SO_RCVLOWAT`和`SO_SNDLOWAT`）表示需要至少这个位数的数据才会执行操作，否则阻塞。

在网络编程中，下列情况下socket可读（不会被阻塞）：
- socket内核接收缓存区中的字节数大于或等于其低水位标记SO_RCVLOWAT。此时我们可以无阻塞地读该socket，并且读操作返回的字节数大于0。
- 监听socket上有新请求。
- socket上有未处理的错误。此时我们可以使用getsockopt来读取和清除该错误。

下列情况下socket可写：
- socket内核发送缓存区中的**可用字节数**大于或等于其低水位标记SO_SNDLOWAT。此时我们可以无阻塞地写该socket，并且写操作返回的字节数大于0。
- socket的写操作被关闭。对写操作被关闭的socket执行写操作将触发一个SIGPIPE信号。
- socket使用非阻塞connect连接成功或者失败（超时）之后。
- socket上有未处理的错误。此时我们可以使用getsockopt来读取和清除该错误。

网络程序中，select能处理的异常情况只有一种：socket上接收到带外数据。

### 9.1.3 处理带外数据

socket上接收到普通数据和带外数据都将使select返回，但socket处于不同的就绪状态：前者处于可读状态，后者处于异常状态。

# 9.2 poll系统调用
poll系统调用和select类似，也是在指定时间内轮询一定数量的文件描述符，以测试其中是否有就绪者。poll的原型如下：

```c
#include<poll.h>
int poll(struct pollfd* fds, nfds_t nfds, int timeout);
```
1. `fds`参数是一个`pollfd`结构数组，它指定所有我们感兴趣的文件描述符上发生的可读、可写和异常等事件。pollfd结构体的定义如下：
```c
struct pollfd
{
int fd;/*文件描述符*/
short events;/*注册的事件*/
short revents;/*实际发生的事件，由内核填充*/
};
```
其中，fd成员指定文件描述符；events成员告诉poll监听fd上的哪些事件，它是一系列事件的按位或；revents成员则由内核修改，以通知应用程序fd上实际发生了哪些事件。poll支持的事件类型如表9-1所示。  
<img src="./picture/9.2.1.png" width="700">   
通常，应用程序需要根据recv调用的返回值来区分socket上接收到的是有效数据还是对方关闭连接的请求，并做相应的处理。不过，自Linux内核2.6.17开始，GNU为poll系统调用增加了一个POLLRDHUP事件，它在socket上接收到对方关闭连接的请求之后触发。这为我们区分上述两种情况提供了一种更简单的方式。但使用POLLRDHUP事件时，我们需要在代码最开始处定义_GNU_SOURCE。

2. `nfds`参数指定被监听事件集合fds的大小。其类型nfds_t的定义如下：
```c
typedef unsigned long int nfds_t;
```

3. `timeout`参数指定poll的超时值，单位是毫秒。当timeout为-1时，poll调用将永远阻塞，直到某个事件发生；当timeout为0时，poll调用将立即返回。

poll返回值和select的返回值含义相同。

通过遍历`fds`数组，通过`revents`字段来查看哪些`socket`有事件发生。通过`fds[i].revents & polll事件类型`来检测，例如：
```c
// **(1) 检查 server_fd 是否有新连接**
if (fds[0].revents & POLLIN) {
    ...
}
```

# 9.3 epoll系列系统调用

## 9.3.1 内核事件表, epoll_create, epoll_ctl
epoll是Linux特有的I/O复用函数。它在实现和使用上与select、poll有很大差异。首先，epoll使用一组函数来完成任务，而不是单个函数。其次，epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中，从而无须像select和poll那样每次调用都要重复传入文件描述符集或事件集。但epoll需要使用一个额外的文件描述符，来唯一标识内核中的这个事件表。这个文件描述符使用如下epoll_create函数来创建：
```c
#include<sys/epoll.h>
int epoll_create(int size);
```
size参数现在并不起作用，只是给内核一个提示，告诉它事件表需要多大。该函数返回的文件描述符将用作其他所有epoll系统调用的第一个参数，以指定要访问的内核事件表。

下面函数用来操作epoll的内核事件表：
```c
#include<sys/epoll.h>
int epoll_ctl(int epfd,int op,int fd,struct epoll_event*event)
```
`epfd`是epoll_create创建的事件表的文件描述符，`fd`参数是要操作的文件描述符，`op`参数则指定操作类型。操作类型有下面三种：
- EPOLL_CTR_ADD，往事件表中注册fd上的事件。
- EPOLL_CTR_MOD，修改fd上的注册事件。
- EPOLL_CTR_DEL，删除fd上的注册事件。

`even`参数指定事件，它是epoll_event结构指针类型。epoll_event的定义如下：
```c
struct epoll_event
{
__uint32_t events;/*epoll事件*/
epoll_data_t data;/*用户数据*/
};
```
其中events成员描述事件类型。epoll支持的事件类型和poll基本相同。表示epoll事件类型的宏是在poll对应的宏前加上“E”，比如epoll的数据可读事件是EPOLLIN。但epoll有两个额外的事件类型——EPOLLET和EPOLLONESHOT。它们对于epoll的高效运作非常关键，我们将在后面讨论它们。data成员用于存储用户数据，其类型epoll_data_t的定义如下：
```c
typedef union epoll_data
{
void*ptr;
int fd;
uint32_t u32;
uint64_t u64;
}epoll_data_t;
```
epoll_data_t是一个联合体，其4个成员中使用最多的是fd，它指定事件所从属的目标文件描述符。ptr成员可用来指定与fd相关的用户数据。但由于epoll_data_t是一个联合体，我们不能同时使用其ptr成员和fd成员，因此，如果要将文件描述符和用户数据关联起来（正如8.5.2小节讨论的将句柄和事件处理器绑定一样），以实现快速的数据访问，只能使用其他手段，比如放弃使用epoll_data_t的fd成员，而在ptr指向的用户数据中包含fd。  

epoll_ctl成功时返回0，失败则返回-1并设置errno。

### 9.3.2 epoll_wait函数
epoll系列系统调用的主要接口是epoll_wait函数。它在一段超时时间内等待一组文件描述符上的事件，其原型如下：
```c
#include<sys/epoll.h>
int epoll_wait(int epfd,struct epoll_event* events,int maxevents,int timeout);
```
该函数成功时返回就绪的文件描述符的个数，失败时返回-1并设置errno。

timeout参数的含义与poll接口的timeout参数相同。maxevents参数指定最多监听多少个事件，它必须大于0。

epoll_wait函数如果检测到事件，就将所有就绪的事件从内核事件表（由epfd参数指定）中复制到它的第二个参数events指向的数组中。这个数组只用于输出epoll_wait检测到的就绪事件，而不像select和poll的数组参数那样既用于传入用户注册的事件，又用于输出内核检测到的就绪事件。这就极大地提高了应用程序索引就绪文件描述符的效率。

## 9.3.3 LT和ET模式
epoll对文件描述符的操作有两种模式：LT（Level Trigger，电平触发）模式和ET（Edge Trigger，边沿触发）模式。LT模式是默认的工作模式，这种模式下epoll相当于一个效率较高的poll。当往epoll内核事件表中注册一个文件描述符上的EPOLLET事件时，epoll将以ET模式来操作该文件描述符。ET模式是epoll的高效工作模式。

对于采用LT工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件。这样，当应用程序下一次调用epoll_wait时，epoll_wait还会再次向应用程序通告此事件，直到该事件被处理。而对于采用ET工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件，因为后续的epoll_wait调用将不再向应用程序通知这一事件。可见，ET模式在很大程度上降低了同一个epoll事件被重复触发的次数，因此效率要比LT模式高。  

设置ET模式或LT模式就是和事件(`epoll_event`结构体中的`events`, `event.events`)进行按位或(`|=`)操作。

**注意** 每个使用ET模式的文件描述符都应该是非阻塞的。如果文件描述符是阻塞的，那么读或写操作将会因为没有后续的事件而一直处于阻塞状态（饥渴状态）。

# 13. 多进程编程

在Linux操作系统中，`内核进程表（Process Table）` 主要用于管理系统中的所有进程。它存储了每个进程的关键信息，使得操作系统能够进行进程调度、管理资源、维护进程状态等。

1. 进程表的结构
Linux内核使用 `进程控制块（Process Control Block，PCB）` 来存储每个进程的信息。在Linux中，`PCB 是一个 task_struct 结构体`，它被组织在一个全局的进程表（任务列表）中。

`task_struct`结构体：  
`task_struct` 是Linux内核中用来表示进程的核心数据结构，它的定义在 include/linux/sched.h 头文件中。以下是其部分关键字段：
```c
struct task_struct {
    pid_t pid;                      // 进程ID
    pid_t tgid;                     // 线程组ID（多线程共享）
    volatile long state;             // 进程状态
    struct list_head tasks;          // 进程链表指针
    struct mm_struct *mm;            // 进程地址空间信息
    struct thread_info *thread;      // 线程相关信息
    struct list_head children;       // 子进程链表
    struct list_head sibling;        // 兄弟进程链表
    struct files_struct *files;      // 进程打开的文件信息
    struct signal_struct *signal;    // 信号处理信息
    struct sched_entity se;          // 进程调度信息
    ...
};
```

2. 内核如何管理进程表
Linux内核使用 双向循环链表 (`task_struct` 里的 `tasks` 字段) 组织所有进程。所有的 `task_struct` 通过 `list_head` 结构体连接，形成进程链表。  
- `init_task`是第一个进程（即`init`进程，PID=1），它是所有进程的祖先。
- `current`宏用于获取当前进程的`task_struct`。

2.1. 进程的创建  
当创建新进程时（如 `fork()` 或 `clone()`），内核会：
1. 分配新的 task_struct 结构。
2. 复制父进程的相关数据（如文件描述符、地址空间等）。
3. 插入到全局进程链表中。



## 13.1 fork系统调用

```c
#include<sys/types.h>
#include<unistd.h>
pid_t fork(void);
```

该函数的每次调用都返回两次，`在父进程中返回的是子进程的PID，在子进程中则返回0`。该返回值是后续代码判断当前进程是父进程还是子进程的依据。fork调用失败时返回-1，并设置errno。

fork函数复制当前进程，在内核进程表中创建一个新的进程表项。新的进程表项有很多属性和原进程相同，比如堆指针、栈指针和标志寄存器的值。但也有许多属性被赋予了新的值，比如该进程的PPID被设置成原进程的PID，信号位图被清除（原进程设置的信号处理函数不再对新进程起作用）。

`fork()`复制了父进程的代码和数据：  
当一个进程调用`fork()`时：  
- 代码段：子进程的代码和父进程完全相同
- 数据段：堆(heap)，栈(stack)，静态数据等都会被复制。  
但这里说的“复制”并不是立即真正复制，而是通过COW机制进行优化。  

写时复制（Copy-On-Write, COW）机制：  
父子进程最初共享相同的内存页（只读），只有当其中一个进程尝试写入该内存时，才会真正复制该内存所在的内存页。  
假设`fork()`后，父子进程共享内存页，当子进程或父进程尝试修改内容时：
1. 子进程或父进程尝试写入 x。
2. 触发缺页异常（Page Fault）。
3. 内核分配新的物理内存页。
4. 将原内存页的数据复制到新页。
5. 修改进程的页表，使其指向新分配的页。
6. 写入新数据，修改才会生效。

创建子进程后，父进程中打开的文件描述符默认在子进程中也是打开的，且文件描述符的引用计数加1。不仅如此，父进程的用户根目录、当前工作目录等变量的引用计数均会加1。

## 13.2 exec系列系统调用

有时我们需要在子进程中执行其他程序，即替换当前进程映像，这就需要使用如下exec系列函数之一：
```c
#include<unistd.h>
int execl(const char*path,const char*arg,...);
int execlp(const char*file,const char*arg,...);
int execle(const char*path,const char*arg,...,char*const envp[]);
int execv(const char*path,char*const argv[]);
int execvp(const char*file,char*const argv[]);
int execve(const char*path,char*const argv[],char*const envp[]);
```

path参数指定可执行文件的完整路径，file参数可以接受文件名，该文件的具体位置则在环境变量PATH中搜寻。arg接受可变参数，argv则接受参数数组，它们都会被传递给新程序（path或file指定的程序）的main函数。envp参数用于设置新程序的环境变量。如果未设置它，则新程序将使用由全局变量environ指定的环境变量。

一般情况下，exec函数是不返回的，除非出错。它出错时返回-1，并设置errno。如果没出错，则原程序中exec调用之后的代码都不会执行，因为此时原程序已经被exec的参数指定的程序完全替换（包括代码和数据）。

exec函数不会关闭原程序打开的文件描述符，除非该文件描述符被设置了类似SOCK_CLOEXEC的属性.

## 13.3 处理僵尸进程

对于多进程程序而言，父进程一般需要跟踪子进程的退出状态。因此，当子进程结束运行时，内核不会立即释放该进程的进程表表项，以满足父进程后续对该子进程退出信息的查询（如果父进程还在运行）。在子进程结束运行之后，父进程读取其退出状态之前，我们称该子进程处于僵尸态。另外一种使子进程进入僵尸态的情况是：父进程结束或者异常终止，而子进程继续运行。此时子进程的PPID将被操作系统设置为1，即init进程。init进程接管了该子进程，并等待它结束。在父进程退出之后，子进程退出之前，该子进程处于僵尸态。

下面这对函数在父进程中调用，以等待子进程的结束，并获取子进程的返回信息，从而避免了僵尸进程的产生，或者使子进程的僵尸态立即结束：
```c
#include<sys/types.h>
#include<sys/wait.h>
pid_t wait(int*stat_loc);
pid_t waitpid(pid_t pid,int*stat_loc,int options);
```

wait函数将阻塞进程，直到该进程的某个子进程结束运行为止。它返回结束运行的子进程的PID，并将该子进程的退出状态信息存储于stat_loc参数指向的内存中。sys/wait.h头文件中定义了几个宏来帮助解释子进程的退出状态信息，如表13-1所示。

<img src="./picture/13.3.1.png" width="700"> 

wait函数的阻塞特性显然不是服务器程序期望的，而waitpid函数解决了这个问题。waitpid只等待由pid参数指定的子进程。如果pid取值为-1，那么它就和wait函数相同，即等待任意一个子进程结束。stat_loc参数的含义和wait函数的stat_loc参数相同。options参数可以控制waitpid函数的行为。该参数最常用的取值是WNOHANG。当options的取值是WNOHANG时，waitpid调用将是非阻塞的：如果pid指定的目标子进程还没有结束或意外终止，则waitpid立即返回0；如果目标子进程确实正常退出了，则waitpid返回该子进程的PID。waitpid调用失败时返回-1并设置errno。

## 13.4 管道
在[5.1 pipe函数](#51-pipe函数)中我们介绍过创建管道的系统调用`pipe`。实际上，管道也是父进程和子进程
间通信的常用手段。  

管道能在父、子进程间传递数据，利用的是fork调用之后两个管道文件描述符（fd[0]和fd[1]）都保持打开。一对这样的文件描述符只能保证父、子进程间一个方向的数据传输，父进程和子进程必须有一个关闭fd[0]，另一个关闭fd[1]。  
例如：  
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>

int main() {
    int fd[2]; // 文件描述符数组
    char buffer[100];
    pid_t pid;

    // 创建管道
    if (pipe(fd) == -1) {
        perror("pipe failed");
        exit(1);
    }

    pid = fork(); // 创建子进程

    if (pid < 0) {
        perror("fork failed");
        exit(1);
    }

    if (pid == 0) {  // 子进程
        close(fd[1]); // 关闭写端
        read(fd[0], buffer, sizeof(buffer)); // 从管道读取数据
        printf("子进程收到消息: %s\n", buffer);
        close(fd[0]); // 关闭读端
    } else {  // 父进程
        close(fd[0]); // 关闭读端
        char msg[] = "Hello from parent!";
        write(fd[1], msg, strlen(msg) + 1); // 向管道写入数据
        close(fd[1]); // 关闭写端
    }

    return 0;
}
```

如果我们想要实现双向数据传输就应该使用`socketpair`函数来实现。

## 13.5 信号量

### 13.5.1 信号量原语

当多个进程同时访问系统上的某个资源的时候，比如同时写一个数据库的某条记录，或者同时修改某个文件，就需要考虑进程的同步问题，以确保任一时刻只有一个进程可以拥有对资源的独占式访问。通常，程序对共享资源的访问的代码只是很短的一段，但就是这一段代码引发了进程之间的竞态条件。我们称这段代码为关键代码段，或者临界区。对进程同步，也就是确保任一时刻只有一个进程能进入关键代码段。

信号量是一种特殊的变量，它只能取自然数值并且只支持两种操作：等待（wait）和信号（signal）。不过在Linux/UNIX中，“等待”和“信号”都已经具有特殊的含义，所以对信号量的这两种操作更常用的称呼是P、V操作。这两个字母来自于荷兰语单词passeren（传递，就好像进入临界区）和vrijgeven（释放，就好像退出临界区）。假设有信号量SV，则对它的P、V操作含义如下：

- P(SV)，如果SV的值大于0，就将它减1；如果SV的值为0，则挂起进程的执行。
- V(SV)，如果有其他进程因为等待SV而挂起，则唤醒之；如果没有，则将SV加1。

信号量的取值可以是任何自然数。但最常用的、最简单的信号量是二进制信号量，它只能取0和1这两个值。

**注意:** 使用一个普通变量来模拟二进制信号量是行不通的，因为所有高级语言都没有一个原子操作可以同时完成如下两步操作：检测变量是否为true/false，如果是则再将它设置为false/true。

Linux信号量的API都定义在sys/sem.h头文件中，主要包含3个系统调用：semget、semop和semctl。它们都被设计为操作一组信号量，即信号量集，而不是单个信号量.

### 13.5.2 `semget`系统调用

semget系统调用创建一个新的信号量集，或者获取一个已经存在的信号量集。其定义如下：


# 14. 多线程编程

## 14.1 创建线程和结束线程

### 14.1.1 `pthread_create`

```c
#include<pthread.h>
int pthread_create(pthread_t* thread, const pthread_attr_t* attr, void*(*start_routine)(void*), void* arg);
```
`thread`参数是新线程的标识符，后续pthread_*函数通过它来引用新线程。
```c
#include<bits/pthreadtypes.h>
typedef unsigned long int pthread_t;
```

attr参数用于设置新线程的属性。给它传递NULL表示使用默认线程属性。线程拥有众多属性，我们将在后面详细讨论之。start_routine和arg参数分别指定新线程将运行的函数及其参数。

pthread_create成功时返回0，失败时返回错误码。

### 14.1.2 `pthread_exit`

线程一旦被创建好，内核就可以调度内核线程来执行start_routine函数指针所指向的函数了。线程函数在结束时最好调用如下函数，以确保安全、干净地退出：
```c
#include<pthread.h>
void pthread_exit(void* retval);
```
pthread_exit函数通过retval参数向线程的回收者传递其退出信息。它执行完之后不会返回到调用者，而且永远不会失败。

### 14.1.3 `pthread_join`
一个进程中的所有线程都可以调用pthread_join函数来回收其他线程（前提是目标线程是可回收的，见后文），即等待其他线程结束，这类似于回收进程的wait和waitpid系统调用。pthread_join的定义如下：
```c
#include<pthread.h>
int pthread_join(pthread_t thread, void**retval);
```
thread参数是目标线程的标识符，retval参数则是目标线程返回的退出信息。该函数会一直阻塞，直到被回收的线程结束为止。该函数成功时返回0，失败则返回错误码。  
|错误码|描述|
|----------|------------|
|EDEADLK|可能引起死锁。比如两个线程互相针对对方调用`pthread_join`，或者线程对自身调用`pthread_join`|
|EINVAL|目标线程是不可回收的，或者已经有其他线程在回收该目标线程|
|ESRCH|目标线程不存在|

### 14.1.4 `pthread_detach`

pthread_detach 的主要作用是：

1. 让线程的资源在终止时自动释放，而无需调用 pthread_join 进行显式回收。
2. 防止线程变成僵尸线程，避免资源泄露。
3. 适用于不需要同步等待的线程，比如后台任务、日志写入等。

```c
#include<pthread.h>
int pthread_detach(pthread_t thread);
```

- thread：需要分离的线程 ID。
- 返回值：
    - 成功：返回 0。
    - 失败：返回错误码，如 ESRCH（线程不存在）或 EINVAL（线程已经是分离状态）。

### 14.1.5 `pthread_cancel`
有时候我们希望异常终止一个线程，即取消线程，它是通过如下函数实现的：
```c
#include<pthread.h>
int pthread_cancel(pthread_t thread);
```
thread参数是目标线程的标识符。该函数成功时返回0，失败则返回错误码。不过，接收到取消请求的目标线程可以决定是否允许被取消以及如何取消，这分别由如下两个函数完成:
```c
int pthread_setcancelstate(int state,int* oldstate);
int pthread_setcanceltype(int type,int* oldtype);
```

这两个函数的第一个参数分别用于设置线程的取消状态（是否允许取消）和取消类型（如何取消），第二个参数则分别记录线程原来的取消状态和取消类型。state参数有两个可选值：
- PTHREAD_CANCEL_ENABLE，允许线程被取消。它是线程被创建时的默认取消状态。
- PTHREAD_CANCEL_DISABLE，禁止线程被取消。这种情况下，如果一个线程收到取消请求，则它会将请求挂起，直到该线程允许被取消。

type参数也有两个可选值：
- PTHREAD_CANCEL_ASYNCHRONOUS，线程随时都可以被取消。它将使得接收到取消请求的目标线程立即采取行动。
- PTHREAD_CANCEL_DEFERRED，允许目标线程推迟行动，直到它调用了下面几个所谓的取消点函数中的一个：pthread_join、pthread_testcancel、pthread_cond_wait、pthread_cond_timedwait、sem_wait和sigwait。根据POSIX标准，其他可能阻塞的系统调用，比如read、wait，也可以成为取消点。不过为了安全起见，我们最好在可能会被取消的代码中调用pthread_testcancel函数以设置取消点。  

pthread_setcancelstate和pthread_setcanceltype成功时返回0，失败则返回错误码。

## 14.2 线程属性

## 14.3 POSIX信号量
pthread_join可以看作一种简单的线程同步方式，不过很显然，它无法高效地实现复杂的同步需求，比如控制对共享资源的独占式访问，又抑或是在某个条件满足之后唤醒一个线程。接下来我们讨论3种专门用于线程同步的机制：POSIX信号量、互斥量和条件变量。

# Http报文
```
GET / HTTP/1.1
Host: 172.23.197.6:12345
Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.7
Accept-Encoding: gzip, deflate
Accept-Language: en-GB,en;q=0.9,zh-CN;q=0.8,zh;q=0.7,en-US;q=0.6


GET /favicon.ico HTTP/1.1
Host: 172.23.197.6:12345
Connection: keep-alive
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/133.0.0.0 Safari/537.36
Accept: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8
Referer: http://172.23.197.6:12345/
Accept-Encoding: gzip, deflate
Accept-Language: en-GB,en;q=0.9,zh-CN;q=0.8,zh;q=0.7,en-US;q=0.6


"HTTP/1.1 200 OK\r\n"
"Content-Type: text/html\r\n"
"Content-Length: " + std::to_string(content_length) + "\r\n"
"\r\n" + std::string(html_content);
```